#!/bin/bash

### EXAMPLE
###
###		cd Sandbox/Stroika-Dev && CONTAINER_NAME=Stroika-Dev CONTAINER_IMAGE=sophistsolutionsinc/stroika-dev ScriptsLib/RunInDockerEnvironment
###


StroikaRoot="${StroikaRoot:=`pwd`}"
CONTAINER_NAME="${CONTAINER_NAME:-regression-tests}"
CONTAINER_IMAGE="${CONTAINER_IMAGE:-sophistsolutionsinc/stroika-buildvm-ubuntu1804-regression-tests}"
EXTRA_DNS="${EXTRA_DNS:-192.168.244.1}"
EXTRA_DOCKER_ARGS="${EXTRA_DOCKER_ARGS:-}"
ECHO_DOCKER_COMMANDS="${ECHO_DOCKER_COMMANDS:-0}"
STOP_AT_END="${STOP_AT_END:-1}"
PRIVATE_COMPILER_BUILDS_DIR="${PRIVATE_COMPILER_BUILDS_DIR:-/private-compiler-builds}"

### Can set CMD2RUN=./ScriptsLib/RegressionTests.sh
CMD2RUN="${CMD2RUN:-bash}"

if [ "${USER_FLAGS}" == "" ] ; then
	USER_FLAGS="-u`id -u` `for i in $( id -G ); do echo -n " --group-add $i "; done`"
fi

# so sudo works, and user name shows up right
PASSWORD_FILE_MOUNTS=-v /etc/passwd:/etc/passwd:ro -v /etc/group:/etc/group:ro -v /etc/shadow:/etc/shadow:ro

if [ $ECHO_DOCKER_COMMANDS -eq 1 ]; then
	echo "***USER_FLAGS = ${USER_FLAGS}"
	echo "***ECHO_DOCKER_COMMANDS = $ECHO_DOCKER_COMMANDS"
	echo "***CMD2RUN = $CMD2RUN"
	echo "***CONTAINER_IMAGE = $CONTAINER_IMAGE"
	echo "***PRIVATE_COMPILER_BUILDS_DIR = $PRIVATE_COMPILER_BUILDS_DIR"
fi

# Silently remove the previous version of the container if it was there before
docker stop ${CONTAINER_NAME} >& /dev/null || true
docker rm ${CONTAINER_NAME} >& /dev/null || true

# -v $HOME:$HOME so we can can re-use/and build to - the my- versions of compilers and cache/re-use those

# -v $HOME/.ssh:$HOME/.ssh:ro so connect to raspberrypi can use ssh keys

# --dns lines since the default for a container is to use global (google) dns server, which doesn't have local dns entries (like raspberrypi device)

# -security-opt seccomp=unconfined  needed to run some google sanitizers (and probbaly to debug?/valgrind?)

# -e COLUMNS=\"`tput cols`\" -e LINES=\"`tput lines`\" doesn't work perfectly, but better than completely shitty display of # of lines 
#  which appears to be the docker default

EXTRATERMARGS=""
if [ "$TERM" != "" ] && [ "$TERM" != "dumb" ]; then
	EXTRATERMARGS="-e COLUMNS=\"`tput cols`\" -e LINES=\"`tput lines`\" -i"
else
	EXTRATERMARGS="-it"
fi


RunCMD_()
{
	CMD=$*
	if [ $ECHO_DOCKER_COMMANDS -eq 1 ]; then
		echo  ${CMD}
	fi
	eval "${CMD}"
}

### If you run docker with the argument script, when the script finishes, the container stops
### restarting the container restarts the script (not what we want here).
### so start with a boring task (sleep inf), and then run the CMD2RUN arg using exec, and then
### stop the container (it can then be safely restarted)

##NB: redirect to /dev/null so container ID not shown - actual errors go to stderr
RunCMD_ "docker run \
	${USER_FLAGS} ${PASSWORD_FILE_MOUNTS} \
	-v /etc/localtime:/etc/localtime:ro \
	-v $HOME/.ssh:$HOME/.ssh \
	-v ${PRIVATE_COMPILER_BUILDS_DIR}:/private-compiler-builds \
	--dns ${EXTRA_DNS} --dns 8.8.8.8 \
	--security-opt seccomp=unconfined \
	$EXTRATERMARGS \
	--name ${CONTAINER_NAME} \
	-h ${CONTAINER_NAME} \
	-v $StroikaRoot:/Sandbox-StroikaRoot \
	--workdir /Sandbox-StroikaRoot \
	${EXTRA_DOCKER_ARGS} \
	--detach \
	${CONTAINER_IMAGE} \
	sleep inf > /dev/null"

# Run this to completion
RunCMD_ docker exec ${CONTAINER_NAME} ${CMD2RUN} 
	
# Then automatically stop the container - simulating if we had done a run of the actual CMD2RUN (except that now)
# you can restart the container without re-running the command
if [ $STOP_AT_END -eq 1 ] ; then
	RunCMD_ docker stop ${CONTAINER_NAME}
fi
