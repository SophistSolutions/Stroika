/*
 * Copyright(c) Sophist Solutions, Inc. 1990-2017.  All rights reserved
 */
#include "Stroika/Frameworks/StroikaPreComp.h"

#include <cstdlib>
#include <iostream>

#include "Stroika/Foundation/Characters/String_Constant.h"
#include "Stroika/Foundation/Characters/ToString.h"
#include "Stroika/Foundation/Execution/Finally.h"
#include "Stroika/Foundation/Execution/Sleep.h"
#include "Stroika/Foundation/Execution/Thread.h"
#include "Stroika/Foundation/Execution/WaitableEvent.h"
#include "Stroika/Frameworks/Service/Main.h"

#include "Service.h"

using namespace std;

using namespace Stroika::Foundation;
using namespace Stroika::Frameworks::Service;

using Characters::String_Constant;
using Execution::Thread;

using namespace Samples::SimpleService;

#if qUseLogger
#include "Stroika/Foundation/Execution/Logger.h"
using Execution::Logger;
#endif

namespace {
    const Main::ServiceDescription kServiceDescription_{
        String_Constant (L"Test-Service"),
        String_Constant (L"Test Service")};
}

void SampleAppServiceRep::MainLoop (const std::function<void()>& startedCB)
{
    /*
     *  All that matters here is that MainLoop already runs in the thread, and it will be notified to terminate with a Thread::Abort () exception.
     *
     *  In here - do what you want for your service, but when this procedure exits, the service terminates.
     *
     *  \note
     *      No NEED to use this technique, but its an easy way to have as many paralell process tasks
     *      ask you want running while your main task does essentially nothing but cleanup when the
     *      service shuts down
     */
    Execution::Thread someOtherTaskDoingRealWork;
    auto&&            cleanup = Execution::Finally ([&]() {
        Thread::SuppressInterruptionInContext suppressSoWeActuallyShutDownOtherTaskWhenWereBeingShutDown;
        /*
         *  Now - we can shutdown any subsidiary threads, and exit
         */
        someOtherTaskDoingRealWork.AbortAndWaitForDone ();
#if qUseLogger
        Logger::Get ().Log (Logger::Priority::eInfo, L"Beginning service shutdown");
#endif
    });

    /*
     *  In your main loop, first run any setup.
     */
    // INITIALIZE_SOMETHING();
    someOtherTaskDoingRealWork = Thread (
        []() {
            Execution::Sleep (1 * 24 * 60 * 60); // wait 1 day ... simple test....
        },
        Thread::eAutoStart);

    startedCB (); // Notify service control mgr that the service has started

#if qUseLogger
    //@todo fix to use #include of autogenerated verison stuff ... Logger::Get ().Log (Logger::Priority::eInfo, L"%s Service (version %s) started", kServiceDescription_.fPrettyName.c_str (), MyServiceVersion::kVersion.AsPrettyVersionString ().c_str ());
    Logger::Get ().Log (Logger::Priority::eInfo, L"Service started successfully");
#endif
    if (false) {
        Execution::WaitableEvent forever (Execution::WaitableEvent::eAutoReset);
        forever.Wait (); // until told to stop by abort exception
    }
    else {
        while (true) {
            // Or you could use a waitable event and wait forever, or do some period bookkeeping.
            Execution::Sleep (1 * 24 * 60 * 60); // wait 1 day ... simple test....
        }
    }

    /*
     *  Cleanups - on exit handled in finally/Cleanup above.
     */
}

Main::ServiceDescription SampleAppServiceRep::GetServiceDescription () const
{
    return kServiceDescription_;
}
