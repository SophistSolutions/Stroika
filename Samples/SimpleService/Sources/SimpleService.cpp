/*
 * Copyright(c) Sophist Solutions, Inc. 1990-2017.  All rights reserved
 */
#include "Stroika/Frameworks/StroikaPreComp.h"

#include <cstdlib>
#include <iostream>

#include "Stroika/Foundation/Characters/String_Constant.h"
#include "Stroika/Foundation/Characters/ToString.h"
#include "Stroika/Foundation/Execution/Finally.h"
#include "Stroika/Foundation/Execution/Sleep.h"
#include "Stroika/Foundation/Execution/Thread.h"
#include "Stroika/Foundation/Execution/WaitableEvent.h"
#include "Stroika/Frameworks/Service/Main.h"

#include "SimpleService.h"

/**
 *  \file
 *
 *  SAMPLE CODE
 *
 *  Sample Simple Service Application
 *
 *  This sample demonstrates a few Stroika features.
 *
 *      o   Creating a service application (one that can be automatically started/stopped by
 *          the OS, and one where you can query the status, check process ID, etc)
 *
 *      o   Simple example of command line processing
 *
 *      o   Simple example of Logging (to syslog or windows log or other)
 */

using namespace std;

using namespace Stroika::Foundation;
using namespace Stroika::Frameworks::Service;

using Containers::Sequence;
using Characters::String_Constant;
using Execution::Thread;

using namespace Samples::SimpleService;

#if qUseLogger
#include "Stroika/Foundation/Execution/Logger.h"
using Execution::Logger;
#endif

namespace {
    const Main::ServiceDescription kServiceDescription_{
        String_Constant (L"Test-Service"),
        String_Constant (L"Test Service")};
}

void SampleAppServiceRep::MainLoop (const std::function<void()>& startedCB)
{
    auto&& cleanup = Execution::Finally ([this]() {
        Thread::SuppressInterruptionInContext suppressSoWeActuallyShutDownOtherTaskWhenWereBeingShutDown;
        /*
         *  Now - we can shutdown any subsidiary threads, and exit
         */
        fSomeOtherTaskDoingRealWork.AbortAndWaitForDone ();
#if qUseLogger
        Logger::Get ().Log (Logger::Priority::eInfo, L"User-service code is shut down");
#endif
    });

    /*
     *  In your main loop, first run any setup.
     */
    // INITIALIZE_SOMETHING();
    fSomeOtherTaskDoingRealWork = Thread (
        []() {
            Execution::Sleep (1 * 24 * 60 * 60); // wait 1 day ... simple test....
        },
        Thread::eAutoStart);

    startedCB (); // Notify service control mgr that the service has started

#if qUseLogger
    //@todo fix to use #include of autogenerated verison stuff ... Logger::Get ().Log (Logger::Priority::eInfo, L"%s Service (version %s) started", kServiceDescription_.fPrettyName.c_str (), MyServiceVersion::kVersion.AsPrettyVersionString ().c_str ());
    Logger::Get ().Log (Logger::Priority::eInfo, L"User-service started");
#endif
    if (false) {
        Execution::WaitableEvent forever (Execution::WaitableEvent::eAutoReset);
        forever.Wait (); // until told to stop by abort exception
    }
    else {
        while (true) {
            // Or you could use a waitable event and wait forever, or do some period bookkeeping.
            Execution::Sleep (1 * 24 * 60 * 60); // wait 1 day ... simple test....
        }
    }

    /*
     *  Cleanups - on exit handled in finally/Cleanup above.
     */
}

Main::ServiceDescription SampleAppServiceRep::GetServiceDescription () const
{
    return kServiceDescription_;
}
