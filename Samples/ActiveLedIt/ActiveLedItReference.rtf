{\rtf1 \ansi {\fonttbl {\f0 \fnil Courier New;}{\f1 \fnil Times New Roman;}}{\colortbl \red0\green0\blue0;\red255\green0\blue0;}
{\*\listtable{\list \listtemplateid18935 {\listlevel \levelnfc23 \leveljc0 \levelfollow0 \levelstartat1 \levelindent0 {\leveltext \levelnfc23 \leveltemplateid17451 \'01\u8226  ?;}\f0 \fi-360 \li720 \jclisttab \tx720 }\listid7616 }}
{\*\listoverridetable{\listoverride \listid7616 \listoverridecount0 \ls1 }}
\deftab720 {\*\generator Sophist Solutions, Inc. Led RTF IO Engine - 3.1a7;}\pard \qc \tx6048 \plain \f1 \fs48 \b \ul \cf1 ActiveLedIt!\plain \f1 \fs48 \cf0   3.1 Reference\par \pard \qc \tx6048 \plain \f1 \fs48 \i \cf0 (pre-release)\plain \f0 \fs24 \cf0 \par \pard \plain \f1 \fs24 \cf0 \par \pard \par \pard \tab ActiveLedIt! is controlled via OLE 
Automation. It has a direct automation API, and it has a callback interface - on
 which you can receive events, or callback notifications of changes to the text.
\par \pard \par \pard \par \pard \plain \f1 \fs28 \b \ul \cf0 ActiveLedIt! HTML <Param> tag arguments:\plain \f1 \fs24 \cf0 \par \pard \par \pard \tab See the web page sample 'Preloadin
gSample.html' for an example of how to use the <PARAM> tags.\par \pard \par \pard \tx6480 \plain \f0 \fs24 \b \cf0 DefaultFontFace\plain \f0 \fs24 \cf0 \par \pard \tab \plain \f1 \fs24 \cf0 S
et the default font name used for the control instance.\par \pard \par \pard \tx6480 \plain \f0 \fs24 \b \cf0 \par \pard \tx6480 DefaultFontSize\plain \f0 \fs24 \cf0 \par \pard \tab \plain \f1 \fs24 \cf0 Set t
he default font size used for the control instance.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \b \cf0 ReadOnly\plain \f0 \fs24 \cf0 \par \pard \tab \plain \f1 \fs24 \cf0 Set the \plain \f0 \fs24 \b \cf0 ReadOnly
\plain \f0 \fs24 \cf0  \plain \f1 \fs24 \cf0 property (see it below).\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \b \cf0 Text\plain \f0 \fs24 \cf0 \par \pard \tab \plain \f1 \fs24 \cf0 Sets all the text of the ActiveLedIt! buffer t
o the argument plain text.\par \pard \tab \plain \f1 \fs24 \i \cf0 NB: Arguments to <PARAM> tags are interpreted by the
 web browser before being passed to the ActiveLedIt control. See "Encoding HTML 
<Param> Tags for default Text specification" below.\plain \f1 \fs24 \cf0 \par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \b \cf0 TextRTF\plain \f0 \fs24 \cf0 \par \pard \tab \plain \f1 \fs24 \cf0 Sets all the text
 of the ActiveLedIt! buffer to the argument RTF text.\par \pard \tab \plain \f1 \fs24 \i \cf0 NB: Arguments to <PARAM> 
tags are interpreted by the web browser before being passed to the ActiveLedIt c
ontrol. See "Encoding HTML <Param> Tags for default Text specification" below.\plain \f1 \fs24 \cf0 \par \pard \par \pard 
\par \pard \tx6480 \plain \f0 \fs24 \b \cf0 TextHTML\plain \f0 \fs24 \cf0 \par \pard \tab \plain \f1 \fs24 \cf0 Sets all the text of the ActiveLedIt! buffer to the argument HTML tex
t.\par \pard \tab \plain \f1 \fs24 \i \cf0 NB: Arguments to <PARAM> tags are interpreted by the web browser before bein
g passed to the ActiveLedIt control. See "Encoding HTML <Param> Tags for default
 Text specification" below.\plain \f1 \fs24 \cf0 \par \pard \tx6480 \par \pard \par \pard \plain \f1 \fs24 \b \ul \cf0 Encoding HTML <Param> Tags for default Text specif
ication:\plain \f1 \fs24 \cf0 \par \pard \par \pard \tab When you use an HTML <PARAM> tag, beware that the value argument is p
arsed and decoded by the HTML interpretter (e.g. Microsoft Internet Explorer).\par \pard \li720 \plain \f0 \fs18 \cf0 <
OBJECT\par \pard \li720 \tab ID="ActiveLedIt"\par \pard \li720 \tab WIDTH=500 HEIGHT=200\par \pard \li720 \tab CLASSID="CLSID:9A013A76-AD34-11D
0-8D9B-00A0C9080C73"\par \pard \li720 >\par \pard \li720 \tab <param Name="Text" Value="1 &lt; 2">\par \pard \li720 </Object>\par \pard \plain \f1 \fs24 \cf0 \par \pard \tab This wi
ll produce the text value "1 < 2" in ActiveLedIt. This is true EVEN THOUGH you u
sed the "Text" attribute instead of "TextHTML". The reason is that the browser i
tself interprets the entity references before passing them to the ActiveX contro
l.\par \pard \par \pard \tab This is something of a problem for the "TextRTF" attribute as well. Ampersa
nds that appear in the RTF content run the risk of being interpreted by HTML int
erpreter as part of an enttiy reference, and thereby changing the meaning of the
 input RTF.\par \pard \par \pard \tab Much worse - if you put HTML text in that context - you are in for
 REAL trouble. The entity references are converted to their values before being 
passed to ActiveLedIt. This breaks the HTML content so that it cannot be interpr
eted properly by ActiveLedIt (because - for example - a user might have had an e
ntity reference '<' or a '"' character which would break how the document was to
 be parsed).\par \pard \par \pard \tab So - when dynamically generating content for a <PARAM> tag, you c
an use the procedure:\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \plain \f0 \fs18 \cf0 <Script Language="JScript" RunAt="Server">\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab function\tab Encod
eStringForHTMLAttribute (s)\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \{\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab // convert special HTML characters to entitie
s\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab var result = "";\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab var sLength = s.length;\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab for (i = 0; i < sLength; ++i
) \{\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab switch (s.charAt(i)) \{\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab case '<': result += "&lt;"; break;\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab case
 '>': result += "&gt;"; break;\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab case '&': result += "&amp;"; break;\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab cas
e '\\"': result += "&quot;"; break;\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab case '\\t': result += "&#09;"; break;\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab 
\tab \tab default:  \{\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab \tab var\tab ccode\tab = s.charCodeAt (i);\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab \tab if ((ccode < 32 || ccode
 > 127) &&\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab \tab     (ccode != 10 && ccode != 13)) \{\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab \tab \tab result +=  "&#" + cc
ode.toString () + ";";\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab \tab \}\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab \tab else \{\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab \tab \tab result += s.charAt(i);\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab \tab 
\}\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \tab \}\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \tab \}\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab \}\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \tab return result;\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 \tab \tab \}\par \pard \tx1080 \tx1440 \tx1800 \tx2160 \tx2520 \li720 \ri-360 </Script>\par \pard \plain \f1 \fs24 \cf0 \par \pard \tab Use that procedure server-
side (as in SimpleActiveLedItASP2FromServerDemo.asp) to encode the input text fo
r the ActiveLedIt control when you are dynamically creating an HTML page.\par \pard \par \pard \par \pard \par \pard \plain \f1 \fs28 \b \ul \cf0 Act
iveLedIt! Automation Interface:\plain \f1 \fs24 \cf0 \par \pard \par \pard \par \pard \plain \f1 \fs24 \b \ul \cf0 Properties:\par \pard \plain \f1 \fs24 \cf0 \tab These can be both retrieved, and 
set (analogous to get/set methods).\par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 int \plain \f0 \fs24 \b \cf0 VersionNumber\plain \f0 \fs24 \cf0 ;\tab [ read-only ]\plain \f0 \fs20 \cf0 \par \pard \plain \f1 \fs24 \cf0 \tab Returns t
he ActiveLedIt! numeric version number. The form of the version number is a 4-by
te longword, computed as:\par \pard \tab \plain \f0 \fs18 \cf0 value=\tab (static_cast<unsigned long> (majorMinor)<<24) 
|\par \pard \tab \tab (static_cast<unsigned long> (versStage)<<16) |\par \pard \tab \tab (static_cast<unsigned long>
 (subStage)<<8) |\par \pard \tab \tab (static_cast<unsigned long> (nonDemoFlag)<<0);\plain \f1 \fs24 \cf0 \par \pard \tab \plain \f0 \fs18 \cf0 #define\tab qLed
_Version_Stage_Dev\tab \tab \tab 0x1\par \pard \tab #define\tab qLed_Version_Stage_Alpha\tab \tab \tab 0x2\par \pard \tab #define\tab qLed_V
ersion_Stage_Beta\tab \tab \tab 0x3\par \pard \tab #define\tab qLed_Version_Stage_ReleaseCandidate\tab 0x4\par \pard \tab #defin
e\tab qLed_Version_Stage_Release\tab \tab \tab 0x5\par \pard \plain \f1 \fs24 \cf0 \par \pard \tab So, for example, ActiveLedIt! 3.0b7 (demo v
ersion) should have a hex version# of 0x30030700. Note - this is the same value 
as the Win32 FILEVERSION. See also \plain \f0 \fs20 \cf0 GetShortVersionString ().\plain \f1 \fs24 \cf0 \par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 BSTR \plain \f0 \fs24 \b \cf0 ShortVersion
String\plain \f0 \fs24 \cf0 ;\plain \f0 \fs24 \b \cf0 \tab \plain \f0 \fs24 \cf0 [ read-only ]\plain \f0 \fs20 \cf0 \par \pard \plain \f1 \fs24 \cf0 \tab Returns a string representation of the ActiveLedIt! versi
on. For example, it might return "3.0b8 - Demo Version" or "3.0b8".\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 int \plain \f0 \fs24 \b \cf0 hWnd\plain \f0 \fs24 \cf0 ;\plain \f0 \fs24 \b \cf0 \tab 
\plain \f0 \fs24 \cf0 [ read-only ]\plain \f0 \fs20 \cf0 \par \pard \plain \f1 \fs24 \cf0 \tab \plain \f1 \fs24 \i \cf0 Standard OLE Stock Property.\par \pard \plain \f1 \fs24 \cf0 \tab Returns the HWND (internal Microsof
t Win32 HWND object pointer) for the ActiveLedIt OLE Control. The type is declar
ed here as 'int' because there is no 'HWND' OLEAUTOMATION type - but it can be s
afely cast to an HWND object.\par \pard \tab Note that this window may contain several other s
ubwindows (HWNDs) to display different parts of the control. Its not recomended 
that you use this HWND, but if you need to, its there. Whatever you find you are
 doing with this, please consult Sophist Solutions, and first see if there is a 
better way, which will be more likely to work with future versions of ActiveLedI
t (as peeking at the HWND is likely to be a fragile appraoch).\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 OLE_COLOR \plain \f0 \fs24 \b \cf0 BackC
olor\plain \f0 \fs24 \cf0 ;\plain \f0 \fs20 \cf0 \tab \plain \f0 \fs24 \cf0 [ read/write ]\plain \f0 \fs20 \cf0 \par \pard \plain \f1 \fs24 \cf0 \tab \plain \f1 \fs24 \i \cf0 Standard OLE Stock Property.\par \pard \plain \f1 \fs24 \cf0 \tab This value defaults to the a
mbient (control containers) 'BackColor' property. Then it can be set or retrieve
d as desired. It changes the background color of the ActiveLedIt! window.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 shor
t \plain \f0 \fs24 \b \cf0 Appearance\plain \f0 \fs24 \cf0 ;\plain \f0 \fs20 \cf0 \tab \plain \f0 \fs24 \cf0 [ read/write ]\plain \f0 \fs20 \cf0 \par \pard \plain \f1 \fs24 \cf0 \tab \plain \f1 \fs24 \i \cf0 Standard OLE Stock Property.\par \pard \plain \f1 \fs24 \cf0 \tab This value defaults 
to the ambient (control containers) Appearance property. Then it can be set or r
etrieved as desired. The appearance of the control: \par \pard \tx1440 \fi-360 \li1440 {\listtext \'b7\tab }\ls1 \ilvl1 0   Flat appearance\par \pard \tx1440 \fi-360 \li1440 {\listtext \'b7\tab }\ls1 \ilvl1 1   3D 
appearance\par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 short \plain \f0 \fs24 \b \cf0 BorderStyle\plain \f0 \fs24 \cf0 ;\plain \f0 \fs20 \cf0 \tab \plain \f0 \fs24 \cf0 [ read/write ]\plain \f0 \fs20 \cf0 \par \pard \plain \f1 \fs24 \cf0 \tab \plain \f1 \fs24 \i \cf0 Standard OLE Stock Property.\par \pard \plain \f1 \fs24 \cf0 \tab Thi
s value defaults to the ambient (control containers) BorderStyle property. Then 
it can be set or retrieved as desired. The border of the control is: \par \pard \tx1440 \fi-360 \li1440 {\listtext \'b7\tab }\ls1 \ilvl1 0   no bor
der\par \pard \tx1440 \fi-360 \li1440 {\listtext \'b7\tab }\ls1 \ilvl1 1   normal border\par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 BOOL \plain \f0 \fs24 \b \cf0 ReadOnly\plain \f0 \fs24 \cf0 ;\tab [ read/write ]\plain \f0 \fs20 \cf0 \par \pard \plain \f1 \fs24 \cf0 \tab When true - the ActiveLedI
t! control allows selection and non-modifiying operations, but no modifications 
can take place. Attempts to edit while read-only result in a BEEP. Defaults to f
alse. See also 'Enabled'.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 BOOL \plain \f0 \fs24 \b \cf0 Enabled\plain \f0 \fs24 \cf0 ;\plain \f0 \fs20 \cf0 \tab \plain \f0 \fs24 \cf0 [ read/write ]\plain \f0 \fs20 \cf0 \par \pard \plain \f1 \fs24 \cf0 \tab \plain \f1 \fs24 \i \cf0 Standard OLE Stock Pro
perty.\par \pard \plain \f1 \fs24 \cf0 \tab When true - the ActiveLedIt! control does nothing but display. There is 
no selection, and no editing enabled. Defaults to false. See also ReadOnly.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 BO
OL \plain \f0 \fs24 \b \cf0 EnableAutoChangesBackgroundColor\plain \f0 \fs24 \cf0 ;\plain \f0 \fs20 \cf0 \tab \plain \f0 \fs24 \cf0 [ read/write ]\plain \f0 \fs20 \cf0 \par \pard \plain \f1 \fs24 \cf0 \tab If true, then disabling or 
making readonly (see ReadOnly/Enabled properties) makes control gray regardless 
of 'BackColor' property. If false, then the 'BackColor' property is always honor
ed. Defaults true.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Boolean \plain \f0 \fs24 \b \cf0 Dirty\plain \f0 \fs24 \cf0 ;\tab [ read/write ]\par \pard \plain \f1 \fs24 \cf0 \tab Document dirty. Automaticall
y set dirty by editing. But flag only cleared by explicitly setting this propert
y.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 enum  HasScrollBarFlag \{\par \pard \tab \plain \f0 \fs24 \b \cf0 eNoScrollBar\plain \f0 \fs24 \cf0 ,\par \pard \tab \plain \f0 \fs24 \b \cf0 eShowScrollBar\plain \f0 \fs24 \cf0 ,\par \pard \tab \plain \f0 \fs24 \b \cf0 eShowScrollbarIfN
eeded\par \pard \plain \f0 \fs24 \cf0 \};\par \pard \tx6480 HasScrollBarFlag \plain \f0 \fs24 \b \cf0 HasVerticalScrollBar\plain \f0 \fs24 \cf0 ;\tab [ read/write ]\par \pard HasScrollBarFlag 
\plain \f0 \fs24 \b \cf0 HasHorizontalScrollBar\plain \f0 \fs24 \cf0 ;\tab [ read/write ]\par \pard \plain \f1 \fs24 \cf0 \tab This property defines whether or not Act
iveLedIt! displays a scrollbar (vertically or horizontally).  \plain \f1 \fs24 \b \cf0 eShowScrollbarIfNe
eded\plain \f1 \fs24 \cf0  means that the scrollbar is shown and hidden automatically, depending on ho
w much text is being displayed.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 int \plain \f0 \fs24 \b \cf0 WindowMarginTop\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 The Wind
owMarginTop is the space between the edge of the text (view rect) and the top of
 the control window (in TWIPS). Its location is relative to the controls boundin
g rectangle.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 int \plain \f0 \fs24 \b \cf0 WindowMarginLeft\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 The WindowMarginLeft is th
e space between the edge of the text (view rect) and the left side of the contro
l window (in TWIPS). Its location is relative to the controls bounding rectangle
.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 int \plain \f0 \fs24 \b \cf0 WindowMarginBottom\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 The WindowMarginBottom is the space
 between the edge of the text (view rect) and the top of the control window (in 
TWIPS). Its location is relative to the controls bounding rectangle.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 int \plain \f0 \fs24 \b \cf0 Windo
wMarginRight\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 The WindowMarginRight is the space between the ri
ght edge of the text (view rect) and the right edige of the control window (in T
WIPS). If there is a scrollbar, it comes to the RIGHT of this value. Its locatio
n is relative to the controls bounding rectangle.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 int \plain \f0 \fs24 \b \cf0 PrintMarginTop\plain \f0 \fs24 \cf0 ; \tab [ read/
write ]\par \pard \tab \plain \f1 \fs24 \cf0 The PrintMarginTop is the space between the top edge of the paper and w
here the text begins printing (in TWIPS).\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 int \plain \f0 \fs24 \b \cf0 PrintMarginLeft\plain \f0 \fs24 \cf0 ; \tab [ read/write ]
\par \pard \tab \plain \f1 \fs24 \cf0 The PrintMarginLeft is the space between the left edge of the paper and where 
the text begins printing (in TWIPS).\par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 \par \pard \tx6480 int \plain \f0 \fs24 \b \cf0 PrintMarginBottom\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 T
he PrintMarginBottom is the space between the bottom edge of the paper and where
 the text ends printing (in TWIPS).\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 int \plain \f0 \fs24 \b \cf0 PrintMarginRight\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 The
 PrintMarginRight is the space between the right edge of the paper and where the
 text ends printing (in TWIPS). Note - this is really only applicable when WrapT
oWindow is true. Otherwise - the text extent to the right is specified by the ru
ler wrapping settings.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 int \plain \f0 \fs24 \b \cf0 MaxUndoLevel\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 0 implies no undo, a
nd 1 implies UNDO has same effect as REDO. Values >1 imply Undo/Redo methods do 
different things. Check CanUndo/CanRedo for more info.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Boolean \plain \f0 \fs24 \b \cf0 CanUndo\plain \f0 \fs24 \cf0 ; \tab [ rea
d-only ]\par \pard \tab \plain \f1 \fs24 \cf0 OK to call Undo () function - something user has done which can be und
one\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Boolean \plain \f0 \fs24 \b \cf0 CanRedo\plain \f0 \fs24 \cf0 ; \tab [ read-only ]\par \pard \tab \plain \f1 \fs24 \cf0 OK to call Redo () function - something u
ser has undone which can be redone\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 BSTR \plain \f0 \fs24 \b \cf0 Text\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 Returns/sets AL
L the text. Returns LF characters as line term (but accepts ANY standard line te
rm on input)\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 BSTR \plain \f0 \fs24 \b \cf0 TextCRLF\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 Returns/sets ALL the text. Always
 returns CR/LF terminated text - even though Led internally uses a single LF for
 paragraph termination. So length of this string isn't same.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 BSTR \plain \f0 \fs24 \b \cf0 TextRTF\plain \f0 \fs24 \cf0 ; \tab [ 
read/write ]\par \pard \plain \f1 \fs24 \cf0 \tab Returns/sets ALL the text. The format of the property is RTF.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 BS
TR \plain \f0 \fs24 \b \cf0 TextHTML\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 Returns/sets ALL the text. The format of the prope
rty is HTML.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 VARIANT \plain \f0 \fs24 \b \cf0 TextBitmap\plain \f0 \fs24 \cf0 ; \tab [ read-only ]\par \pard \tab \plain \f1 \fs24 \cf0 Returns ALL the text in the f
orm of a bitmap. Simulates a print command. The returned image is an OLE Picture
 object (supporting the IPicture interface) created with OleCreatePictureIndirec
t  ().\par \pard \tab NOTE - this differs from earlier versions of ActiveLedIt! which returned
 the bitmap as a DIB - saved in a SAFEARRAY (UINT8).\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Long \plain \f0 \fs24 \b \cf0 Length\plain \f0 \fs24 \cf0 ; \tab [ read-only
 ]\par \pard \tab \plain \f1 \fs24 \cf0 Returns the total number of characters in the buffer. Note this DOESNT corre
spond to length (Text), cuz that returns CRLF text\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Long \plain \f0 \fs24 \b \cf0 MaxLength\plain \f0 \fs24 \cf0 ; \tab [ read/wri
te ]\par \pard \tab \plain \f1 \fs24 \cf0 Maximum length (in characters, with CR/LF treated as ONE) of the input buf
fer. -1 => no maximum.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Boolean \plain \f0 \fs24 \b \cf0 SupportContextMenu\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 If enabled
, right-clicks bring up context menu.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Boolean \plain \f0 \fs24 \b \cf0 SmartCutAndPaste\plain \f0 \fs24 \cf0 ; \tab [ read/write 
]\par \pard \tab \plain \f1 \fs24 \cf0 If enabled, try to make good guesses about cutting/pasting extra whitespace (
and drag and drop).\par \pard \plain \f0 \fs24 \cf0 \par \pard \plain \f1 \fs24 \cf0 \par \pard \tx6480 \plain \f0 \fs24 \cf0 Boolean \plain \f0 \fs24 \b \cf0 SmartQuoteMode\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \plain \f1 \fs24 \cf0 \tab If enabled, repla
ce a typed double quote character (") with either an open quote (\ldblquote ) or close quo
te (\rdblquote ) character. Note that this doesn't apply to pasted text - only to characte
rs typed from the keyboard.\par \pard \plain \f0 \fs24 \cf0 \par \pard \plain \f1 \fs24 \cf0 \par \pard \tx6480 \plain \f0 \fs24 \cf0 boolean \plain \f0 \fs24 \b \cf0 WrapToWindow\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 If true, th
en text is wrapped to the window, and otherwise to the ruler (page). This only a
ffects the rightmost margin.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Boolean \plain \f0 \fs24 \b \cf0 ShowParagraphGlyphs\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 If 
true, end-of-paragraph glyphs are displayed.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Boolean \plain \f0 \fs24 \b \cf0 ShowTabGlyphs\plain \f0 \fs24 \cf0 ; \tab [ read/wr
ite ]\par \pard \tab \plain \f1 \fs24 \cf0 If true, tab glyphs are displayed (not just empty space - but an icon so 
you can see them).\par \pard \tab \tab \tab \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Boolean \plain \f0 \fs24 \b \cf0 ShowSpaceGlyphs\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 If true, space
 glyphs are displayed (not just empty space - but an icon so you can see them\par \pard \par \pard \par \pard \tx6480 
\plain \f0 \fs24 \cf0 Boolean \plain \f0 \fs24 \b \cf0 ShowSecondaryHilight\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 If true (default) then then even 
when the control is deactivated (not the focused control), a subtle indication o
f the selected region (if non-empty) will still be shown.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Boolean \plain \f0 \fs24 \b \cf0 UseSelectEOL
BOLRowHilightStyle\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 If true (default) then selections will hili
ght to the end of line (and beginning of line) for newlines. This display is how
 all versions of ActiveLedIt displayed hilights in versions 3.0 and earlier, and
 its the standard way on the MacOS. Windows is a bit more inconsistent - but I t
hink this was is better (defaults on).\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Boolean \plain \f0 \fs24 \b \cf0 ShowHidableText\plain \f0 \fs24 \cf0 ; \tab [ read/write 
]\par \pard \tab \plain \f1 \fs24 \cf0 If true, hidable text (RTF \\v) is displayed in the HidableTextColor, and the 
strike-through style.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 OLE_COLOR \plain \f0 \fs24 \b \cf0 HidableTextColor\plain \f0 \fs24 \cf0 ;\tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 See ShowHida
bleText. This color is used to augment the display of hidable text which is curr
ently being displayed if HidableTextColored is true.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Boolean \plain \f0 \fs24 \b \cf0 HidableTextColore
d\plain \f0 \fs24 \cf0 ;\tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 See ShowHidableText. If true, then use 'HidableTextColor' to 
color hidable text which is shown. Otherwise - use (default) light gray underlin
e.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 VARIANT \plain \f0 \fs24 \b \cf0 SpellChecker\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 Reading this property will return an
 IDispatch* pointer to the current spellcheck engine associated with this Active
LedIt instance. It defaults to returning \plain \f1 \fs24 \b \cf0 null\plain \f1 \fs24 \cf0 . You can assign to this property e
ither a spellchecker object instance (IDispatch*) or a string representing its C
LSID or PROGID.\par \pard \tab In principle - the spellchecker refered to by IDispatch*, progi
d or whatever could be any spellcheck engine. Check with Sophist Solutions for a
 list of what spellcheck engines are supported.\par \pard \tab So for example -  to enable spe
llchecking - you could instantiate your own ActiveSpelledIt checker and assign i
t as follows:\par \pard \li1440 \sb100 \plain \f0 \fs20 \cf0 var\tab spellChecker = GetObject (\ldblquote ActiveSpelledIt.Control\rdblquote );\par \pard \li1440 \sa100 activeLe
dIt.SpellChecker = spellChecker;\par \pard \plain \f1 \fs24 \cf0 \tab or - alternatively - you could simply write:\par \pard \li1440 \sb100 \plain \f0 \fs20 \cf0 a
ctiveLedIt.SpellChecker = \ldblquote ActiveSpelledIt.Control\rdblquote ;\par \pard \plain \f1 \fs24 \cf0 \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Long \plain \f0 \fs24 \b \cf0 SelStart\plain \f0 \fs24 \cf0 ; \tab [ read/wr
ite ]\par \pard \tab \plain \f1 \fs24 \cf0 Returns/sets START of the selection (nb: offsets assume a paragraph-term 
single char).\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Long \plain \f0 \fs24 \b \cf0 SelLength\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\plain \f1 \fs24 \cf0 \par \pard \tab Returns/sets LENGTH of the sele
ction (nb: offsets assume a paragraph-term single char).\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 BSTR \plain \f0 \fs24 \b \cf0 SelText\plain \f0 \fs24 \cf0 ; \tab [ read
/write ]\par \pard \plain \f1 \fs24 \cf0 \tab Returns/sets the selected text (if any).  (but accepts ANY standard li
ne term on input\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 BSTR \plain \f0 \fs24 \b \cf0 SelTextRTF\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 Returns/sets the selected t
ext (in RTF format - and can be stuff other than text - so long as in RTF format
.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 BSTR \plain \f0 \fs24 \b \cf0 SelTextHTML\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \plain \f1 \fs24 \cf0 \tab Returns/sets the selected text (in RTF fo
rmat - and can be stuff other than text - so long as in RTF format).\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 OLE_COLOR
 \plain \f0 \fs24 \b \cf0 SelColor\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \plain \f1 \fs24 \cf0 \tab Returns/sets the color of the selected text (or inse
rtion point if selection empty).\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 BSTR \plain \f0 \fs24 \b \cf0 SelFontFace\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \plain \f1 \fs24 \cf0 \tab Returns/se
ts the FontFace of the selected text (or insertion point if selection empty).\par \pard \par \pard \par \pard \tx6480 
\plain \f0 \fs24 \cf0 long \plain \f0 \fs24 \b \cf0 SelFontSize\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \plain \f1 \fs24 \cf0 \tab Returns/sets the Font Size of the selected te
xt (or insertion point if selection empty - in Points).\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 long \plain \f0 \fs24 \b \cf0 SelBold\plain \f0 \fs24 \cf0 ; \tab [ read/
write ]\par \pard \tab \plain \f1 \fs24 \cf0 Returns/sets the Font Style BOLD of the selected text (or insertion poi
nt if selection empty). 0=>false, 1=>true, 2=>no-universal-answer.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 long \plain \f0 \fs24 \b \cf0 SelIta
lic\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \plain \f1 \fs24 \cf0 \tab Returns/sets the Font Style Italic of the selected text (o
r insertion point if selection empty). 0=>false, 1=>true, 2=>no-universal-answer
.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 long \plain \f0 \fs24 \b \cf0 SelStrikeThru\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \plain \f1 \fs24 \cf0 \tab Returns/sets the Font Style StrikeThru 
of the selected text (or insertion point if selection empty). 0=>false, 1=>true,
 2=>no-universal-answer.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 long \plain \f0 \fs24 \b \cf0 SelUnderline\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \plain \f1 \fs24 \cf0 \tab Returns/sets the 
Font Style Underline of the selected text (or insertion point if selection empty
). 0=>false, 1=>true, 2=>no-universal-answer.\par \pard \par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 enum JustificationFlag \{\par \pard     \plain \f0 \fs24 \b \cf0 eL
eftJustification\plain \f0 \fs24 \cf0 , \par \pard     \plain \f0 \fs24 \b \cf0 eRightJustification\plain \f0 \fs24 \cf0 ,\par \pard     \plain \f0 \fs24 \b \cf0 eCenterJustification\plain \f0 \fs24 \cf0 ,\par \pard     \plain \f0 \fs24 \b \cf0 eFullJ
ustification\plain \f0 \fs24 \cf0 ,\par \pard     \plain \f0 \fs24 \b \cf0 eNoCommonJustification\plain \f0 \fs24 \cf0 \par \pard \};\par \pard \tx6480 JustificationFlag \plain \f0 \fs24 \b \cf0 SelJustification\plain \f0 \fs24 \cf0 ; 
\tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 Returns/sets the Justification of the selected paragraphs. eNoC
ommonJustification =>no-universal-answer, can be returned - but not set. FullJus
tification not fully supported (displayed as left-justification).\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 enum ListSty
le \{\par \pard \tab \plain \f0 \fs24 \b \cf0 eListStyle_None = 9999,\par \pard \tab eListStyle_Bullet = 23,\par \pard \tab eNoCommonListStyle = -1\plain \f0 \fs24 \cf0 \par \pard 
\};\par \pard \tx6480 ListStyle \plain \f0 \fs24 \b \cf0 SelListStyle\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \tab \plain \f1 \fs24 \cf0 Returns/sets the ListStyle of the se
lected paragraphs. The enumerator eNoCommonListStyle implies no-universal-answer
 can be returned when the property is read and is not a legal value to set the p
roperty to.\par \pard \par \pard \par \pard \tx6480 \plain \f0 \fs24 \cf0 Long \plain \f0 \fs24 \b \cf0 SelHidable\plain \f0 \fs24 \cf0 ; \tab [ read/write ]\par \pard \plain \f1 \fs24 \cf0 \tab Returns/sets the Hidable flag of
 the selected text. 0=>false, 1=>true, 2=>no-universal-answer.\par \pard \par \pard \par \pard \par \pard \plain \f1 \fs24 \b \ul \cf0 Methods:\par \pard \plain \f1 \fs24 \cf0 \tab Thes
e are normal methods (functions) which apply to the given ActiveLedIt! control (
not to be confused with properties).\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 AboutBox\plain \f0 \fs24 \cf0  ();\par \pard \plain \f1 \fs24 \cf0 \tab Displays the modal abo
utbox.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 LoadFile\plain \f0 \fs24 \cf0  ([in]BSTR filename);\par \pard \plain \f1 \fs24 \cf0 \tab Loads a file into the control. This
 routine will guess the file format, based on the file extension, and perhaps it
s contents.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 SaveFile\plain \f0 \fs24 \cf0  ([in]BSTR filename);\par \pard \tab \plain \f1 \fs24 \cf0 Saves the contents of the cont
rol to the named file. Guess the file format based on the file name.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 Save
FileCRLF\plain \f0 \fs24 \cf0  ([in]BSTR filename);\tab \par \pard \tab \plain \f1 \fs24 \cf0 Saves the contents of the control to the named f
ile as CRLF-terminated text.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 SaveFileRTF\plain \f0 \fs24 \cf0  ([in]BSTR filename);\par \pard \tab \plain \f1 \fs24 \cf0 Saves the 
contents of the control to the named file as RTF.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 SaveFileHTML\plain \f0 \fs24 \cf0  ([in]BSTR 
filename);\par \pard \plain \f1 \fs24 \cf0 \tab Saves the contents of the control to the named file as HTML.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void 
\plain \f0 \fs24 \b \cf0 Refresh\plain \f0 \fs24 \cf0  ();\par \pard \plain \f1 \fs24 \cf0 \tab Forces a complete repaint of a control.\tab \par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 ScrollToSelection\plain \f0 \fs24 \cf0  (
);\par \pard \plain \f1 \fs24 \cf0 \tab Scroll the current window so that the selection is shown.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 Undo\plain \f0 \fs24 \cf0  ();\par \pard \plain \f1 \fs24 \cf0 \tab U
ndo last user action (same as menu command undo). If CanRedo and MaxUndoLevel==1
, same as Redo (). NB: unlike UI undo command - doesn't scrolltoselection afterw
ards.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 Redo\plain \f0 \fs24 \cf0  ();\par \pard \plain \f1 \fs24 \cf0 \tab Redo last undone action (same as menu command redo). NB: 
unlike UI undo command - doesn't scrolltoselection afterwards.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 CommitUndo
\plain \f0 \fs24 \cf0  ();\par \pard \plain \f1 \fs24 \cf0 \tab Erases existing Undo/Redo history. Future user actions can still be undone
.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 LaunchFontSettingsDialog\plain \f0 \fs24 \cf0  ();\par \pard \plain \f1 \fs24 \cf0 \tab Bring up the Font Settings Dialog.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void
 \plain \f0 \fs24 \b \cf0 LaunchParagraphSettingsDialog\plain \f0 \fs24 \cf0  ();\par \pard \plain \f1 \fs24 \cf0 \tab Bring up the Paragraph Settings Dialog.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 vo
id \plain \f0 \fs24 \b \cf0 LaunchFindDialog\plain \f0 \fs24 \cf0  ();\par \pard \plain \f1 \fs24 \cf0 \tab Bring up the Find Dialog, so the user can type in text 
and search. See also the 'Find' method.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 long \plain \f0 \fs24 \b \cf0 Find\plain \f0 \fs24 \cf0  (\par \pard \tab \tab [in]long searchFrom, \par \pard  \tab 
\tab [in]VARIANT findText, \par \pard \tab \tab [in,defaultvalue(TRUE)]BOOL wrapSearch,\par \pard \tab \tab [in,defaultv
alue(FALSE)]BOOL wholeWordSearch,       \par \pard \tab \tab [in,defaultvalue(FALSE)]BOOL caseSens
ativeSearch\par \pard \tab );\par \pard \plain \f1 \fs24 \cf0 \tab Search from the given position, using the given parameters. Ret
urn offset in text where specified string is found, or -1 if none. Doesn't chang
e selection. See also the 'LaunchFindDialog' method.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 LaunchReplaceDialog\plain \f0 \fs24 \cf0  
();\par \pard \plain \f1 \fs24 \cf0 \tab Bring up the Find/Replace Dialog, so the user can type in text and search a
nd have that text replaced with other entered text. See also the \ldblquote \plain \f0 \fs24 \cf0 FindReplace\plain \f1 \fs24 \cf0 \ldblquote  m
ethod and the \ldblquote \plain \f0 \fs24 \cf0 LaunchFindDialog\plain \f1 \fs24 \cf0 \rdblquote  method.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 long \plain \f0 \fs24 \b \cf0 FindReplace\plain \f0 \fs24 \cf0  (\par \pard \tab \tab [in]long searchF
rom, \par \pard  \tab \tab [in]VARIANT findText, \par \pard \tab \tab [in]VARIANT replaceText, \par \pard \tab \tab [in,defaultvalue(T
RUE)]BOOL wrapSearch,\par \pard \tab \tab [in,defaultvalue(FALSE)]BOOL wholeWordSearch,       \par \pard \tab \tab [
in,defaultvalue(FALSE)]BOOL caseSensativeSearch\par \pard \tab );\par \pard \plain \f1 \fs24 \cf0 \tab Search for the given '\plain \f0 \fs24 \cf0 findT
ext\plain \f1 \fs24 \cf0 ' from the given offset, and replace with '\plain \f0 \fs24 \cf0 replaceText\plain \f1 \fs24 \cf0 '. Return offset of \plain \f1 \fs24 \i \cf0 end
\plain \f1 \fs24 \cf0  of where replace text inserted, if successfull, or -1 if search text not found.
 See also the '\plain \f0 \fs24 \cf0 LaunchReplaceDialog\plain \f1 \fs24 \cf0 ' method and the '\plain \f0 \fs24 \cf0 Find\plain \f1 \fs24 \cf0 ' method.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 Printer
SetupDialog\plain \f0 \fs24 \cf0  ();\par \pard \plain \f1 \fs24 \cf0 \tab Bring up the 'Printer Setup' dialog. This is the same as the 'P
rinter setup' command accessible from the context menu.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f1 \fs24 \b \cf0 PrintDialog\plain \f0 \fs24 \cf0  ();\par \pard \plain \f1 \fs24 \cf0 \tab 
Bring up the standard 'Print' dialog. This is the same as the 'Print' command ac
cessible from the context menu\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f1 \fs24 \b \cf0 PrintOnce\plain \f0 \fs24 \cf0  ();\par \pard \plain \f1 \fs24 \cf0 \tab Print the current document 
once. Like the 'Print Dialog' method - except that it brings up no prompting dia
log (though it does display a progress dialog).\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 int \plain \f0 \fs24 \b \cf0 GetHeight\plain \f0 \fs24 \cf0  (\par \pard \tab \tab [in,defaultv
alue(-1)]INT from,\par \pard \tab \tab [in,defaultvalue(-1)]INT to\par \pard \tab );\par \pard \plain \f1 \fs24 \cf0 \tab Compute the height of the 
given document range (from to to) in pixels. 'from' and 'to' default to the star
t and end of the document\par \pard \tab  Note this function can be slow to compute for large 
documents - as it may cause word-wrap computations for the entire range requeste
d.\par \pard \tab Note also that this does \plain \f1 \fs24 \i \cf0 not\plain \f1 \fs24 \cf0  exactly compute the number of pages you would e
xpect when printing - because printing often inserts extra spaces at the end of 
pages so we don't display partial rows.\par \pard \tab This function includes the last row ref
erenced in its heihgt computation. So - for example - if you ask for the height 
from X,X - you WONT get back zero - but the height of the row containing positio
n X.\par \pard \par \pard \par \pard \par \pard \par \pard \par \pard \plain \f1 \fs28 \b \ul \cf0 ActiveLedIt! Event (callback) Interface:\plain \f1 \fs24 \cf0 \par \pard \par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 Change\plain \f0 \fs24 \cf0  ();\par \pard \tab \plain \f1 \fs24 \cf0 Indicates
 that the contents of a control have changed.\par \pard \tab \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 Click\plain \f0 \fs24 \cf0  ();\par \pard \plain \f1 \fs24 \cf0 \tab Occurs when the
 user presses and then releases the left mouse button over an object. Note that 
we intentionally do NOT trigger a \plain \f0 \fs24 \cf0 Click\plain \f1 \fs24 \cf0  event for a right-click (though you stil
l get \plain \f0 \fs24 \cf0 MouseUp\plain \f1 \fs24 \cf0  and \plain \f0 \fs24 \cf0 MouseDown\plain \f1 \fs24 \cf0  events).\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 DblClick\plain \f0 \fs24 \cf0  ();\par \pard \plain \f1 \fs24 \cf0 \tab Occurs when the user p
resses and releases the left mouse button and then presses and releases it again
 over an object. Note that we intentionally do NOT trigger a \plain \f0 \fs24 \cf0 Click\plain \f1 \fs24 \cf0  event for a r
ight-click (though you still get \plain \f0 \fs24 \cf0 MouseUp\plain \f1 \fs24 \cf0  and \plain \f0 \fs24 \cf0 MouseDown\plain \f1 \fs24 \cf0  events).\par \pard \tab \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 KeyDown\plain \f0 \fs24 \cf0  
(short* KeyCode,short Shift);\par \pard \plain \f1 \fs24 \cf0 \tab Occurs when the user presses a key while an objec
t has the focus.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 KeyUp\plain \f0 \fs24 \cf0  (short* KeyCode, short Shift);\par \pard \plain \f1 \fs24 \cf0 \tab Occurs when the us
er releases a key while an object has the focus.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 KeyPress\plain \f0 \fs24 \cf0  (short* KeyAsci
i);\par \pard \plain \f1 \fs24 \cf0 \tab Occurs when the user presses and releases an ANSI key.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 MouseDown\plain \f0 \fs24 \cf0  (\par \pard \tab 
short Button, \par \pard \tab short Shift, \par \pard \tab OLE_XPOS_PIXELS x, \par \pard \tab OLE_YPOS_PIXELS y\par \pard );\par \pard \plain \f1 \fs24 \cf0 \tab Occurs
 when the user presses a mouse button (either left or right).\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 MouseMove\plain \f0 \fs24 \cf0  (
\par \pard \tab short Button, \par \pard \tab short Shift, \par \pard \tab OLE_XPOS_PIXELS x, \par \pard \tab OLE_YPOS_PIXELS y\par \pard );\par \pard \plain \f1 \fs24 \cf0 \tab Occu
rs when the user moves the mouse.\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 MouseUp\plain \f0 \fs24 \cf0  (\par \pard \tab short Button, \par \pard \tab short Shift,
 \par \pard \tab OLE_XPOS_PIXELS x,\par \pard \tab OLE_YPOS_PIXELS y\par \pard );\par \pard \plain \f1 \fs24 \cf0 \tab Occurs when the user presses and re
leases a mouse button (either left or right).\par \pard \par \pard \par \pard \plain \f0 \fs24 \cf0 void \plain \f0 \fs24 \b \cf0 SelChange\plain \f0 \fs24 \cf0  ();\par \pard \tab \plain \f1 \fs24 \cf0 Occurs when 
the current selection of text in the ActiveLedIt control has changed or the inse
rtion point has moved.}