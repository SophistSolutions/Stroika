/*
 * Copyright(c) Records For Living, Inc. 2004-2011.  All rights reserved
 */
#include	"../StroikaPreComp.h"

#include	<algorithm>
#include	<cstdio>
#include	<tchar.h>

#include	"../Memory/SmallStackBuffer.h"

#include	"../Configuration/Basics.h"


using	namespace	Stroika;
using	namespace	Stroika::Foundation;

#ifndef	qBuildInTableDrivenCodePageBuilderProc
	#define	qBuildInTableDrivenCodePageBuilderProc		0
#endif


/*
 *	Hack to build 'myiswalpha' and 'myiswpunct' for SPR#1220 (revised and moved here for SPR#1306 and class
 *	'CharacterProperties').
 */
#ifndef	qBuildMemoizedISXXXBuilderProc
	#define	qBuildMemoizedISXXXBuilderProc				0
#endif



/*
 *	Use this to test my IsWXXX functions produce the right results. Only test under WinXP,
 *	since that is the reference they are copying (SPR#1229).
 */
#ifndef	qTestMyISWXXXFunctions
	#define	qTestMyISWXXXFunctions						0
#endif





#if		qBuildInTableDrivenCodePageBuilderProc || qBuildMemoizedISXXXBuilderProc
	#include	<fstream>
#endif





#include	"CodePage.h"




using	namespace	CodePageUtils;





namespace {

	#if		qBuildInTableDrivenCodePageBuilderProc
		static	void	WriteCodePageTable (CodePage codePage);

		struct	DoRunIt {
			DoRunIt ()
			{
				//WriteCodePageTable (kCodePage_ANSI);
				//WriteCodePageTable (kCodePage_MAC);
				//WriteCodePageTable (kCodePage_PC);
				//WriteCodePageTable (kCodePage_PCA);
				//WriteCodePageTable (kCodePage_GREEK);
				//WriteCodePageTable (kCodePage_Turkish);
				//WriteCodePageTable (kCodePage_HEBREW);
				//WriteCodePageTable (kCodePage_ARABIC);
			}
		}	gRunIt;
	#endif


	#if		qBuildMemoizedISXXXBuilderProc
	template	<class FUNCTION>
		void	WriteMemoizedIsXXXProc (FUNCTION function, const string& origFunctionName, const string& functionName)
				{
					ofstream	outStream ("IsXXXProc.txt");

					outStream << "bool	" << functionName << " (wchar_t c)\n";
					outStream << "{\n";

					outStream << "\t// ********** " << functionName << " (AUTOGENERATED memoize of " << origFunctionName << " - " << __DATE__ << ") ***********\n";
					outStream << "\t// Hack for SPR#1220 and SPR#1306\n";

					// SPR#1308 - the generated if/then skipchain can be somewhat long, and therefore inefficient.
					// This is needlessly so. In principle - we could break up the long skipchain into many smaller ones
					// nested hierarchically. This would involve first pre-computing the entire list of regions, and
					// then generating the if/then code recursively since before you can generate INNER code you need
					// to know the full range of codepoints contained in all contained ifs.
					//
					// Anyhow - there is a trivial implementation that gets us most of the speedup we seek - since most
					// characters looked up fall in the 0..256 range. So - just handle that specially.
					//

					const	wchar_t	kBoundaryForSpecailLoop1	=	255;
					const	wchar_t	kBoundaryForSpecailLoop2	=	5000;

					for (int j = 0; j <= 2; ++j) {

						if (j == 0) {
							outStream << "\tif (c < " << int (kBoundaryForSpecailLoop1) << ") {\n";
						}
						else if (j == 1) {
							outStream << "\telse if (c < " << int (kBoundaryForSpecailLoop2) << ") {\n";
						}
						else {
							outStream << "\telse {\n";
						}

						outStream << "\t\tif (";
						bool	firstTime	=	true;
						bool	hasLastTrue	=	false;
						size_t	firstRangeIdxTrue	=	0;
						size_t	startLoop			=	0;
						size_t	endLoop				=	0;
						if (j == 0) {
							endLoop = kBoundaryForSpecailLoop1;
						}
						else if (j == 1) {
							startLoop = kBoundaryForSpecailLoop1;
							endLoop = kBoundaryForSpecailLoop2;
						}
						else {
							startLoop = kBoundaryForSpecailLoop2;
							endLoop = 256*256;
						}
						for (size_t i = startLoop; i < endLoop; ++i) {
							bool	isT		=	function (static_cast<wchar_t> (i));

							if (((not isT) or (i + 1 == endLoop))  and hasLastTrue) {
								// then emit the range...
								if (not firstTime) {
									outStream << "\t\t\t||";
								}
								size_t	rangeEnd	=	isT? i: i-1;
								outStream << "(" << firstRangeIdxTrue << " <= c && c <= " << rangeEnd << ")";
								firstTime = false;
								outStream << "\n";
								hasLastTrue = false;
							}
							if (isT and not hasLastTrue) {
								firstRangeIdxTrue = i;
								hasLastTrue = true;
							}
						}
						if (firstTime) {
							outStream << "false";
						}

						outStream << "\t\t\t) {\n";
						outStream << "\t\t\t#if		qTestMyISWXXXFunctions\n";
						outStream << "\t\t\tAssert (" << origFunctionName << "(c));\n";
						outStream << "\t\t\t#endif\n";
						outStream << "\t\t\treturn true;\n";
						outStream << "\t\t}\n";

						outStream << "\t}\n";

					}
					outStream << "\t#if		qTestMyISWXXXFunctions\n";
					outStream << "\tAssert (!" << origFunctionName << "(c));\n";
					outStream << "\t#endif\n";
					outStream << "\treturn false;\n";
					outStream << "}\n";
					outStream << "\n";
				}

		struct	DoRunIt {
			DoRunIt ()
			{
				WriteMemoizedIsXXXProc (iswalpha, "iswalpha", "CharacterProperties::IsAlpha_M");
				//WriteMemoizedIsXXXProc (iswalnum, "iswalnum", "CharacterProperties::Ialnum_M");
				//WriteMemoizedIsXXXProc (iswpunct, "iswpunct", "CharacterProperties::IsPunct_M");
				//WriteMemoizedIsXXXProc (iswspace, "iswspace", "CharacterProperties::IsSpace_M");
				//WriteMemoizedIsXXXProc (iswcntrl, "iswcntrl", "CharacterProperties::IsCntrl_M");
				//WriteMemoizedIsXXXProc (iswdigit, "iswdigit", "CharacterProperties::IsDigit_M");
			}
		}	gRunIt;
	#endif


	#if		qTestMyISWXXXFunctions
		class	MyIsWXXXTesterFunctions {
			public:
				MyIsWXXXTesterFunctions ()
					{
						for (wchar_t c = 0; c < 0xffff; ++c) {
							Assert (CharacterProperties::IsAlpha_M (c) == !!iswalpha (c));
							Assert (CharacterProperties::IsAlnum_M (c) == !!iswalnum (c));
							Assert (CharacterProperties::IsPunct_M (c) == !!iswpunct (c));
							Assert (CharacterProperties::IsSpace_M (c) == !!iswspace (c));
							Assert (CharacterProperties::IsCntrl_M (c) == !!iswcntrl (c));
							Assert (CharacterProperties::IsDigit_M (c) == !!iswdigit (c));
						}
					}
		}	sMyIsWXXXTesterFunctions;
	#endif

}




/*
 ********************************************************************************
 ******************************** CodePageConverter *****************************
 ********************************************************************************
 */
void	CodePageUtils::MapSBUnicodeTextWithMaybeBOMToUNICODE (const char* inMBChars, size_t inMBCharCnt, wchar_t* outChars, size_t* outCharCnt)
{
	RequireNotNil (outChars);
	RequireNotNil (outCharCnt);
	size_t							outBufSize	=	*outCharCnt;
	CodePagesGuesser::Confidence	confidence	=	CodePagesGuesser::eLow;
	CodePage						cp			=	CodePagesGuesser ().Guess (inMBChars, inMBCharCnt, &confidence, NULL);
	if (confidence <= CodePagesGuesser::eLow) {
		cp = CP_UTF8;
	}
	CodePageConverter cpCvt (cp, CodePageConverter::eHandleBOM);
	cpCvt.MapToUNICODE (inMBChars, inMBCharCnt, outChars, outCharCnt);
	Ensure (*outCharCnt <= outBufSize);
}





/*
 ********************************************************************************
 ******************************** CodePageConverter *****************************
 ********************************************************************************
 */
/*
@METHOD:		CodePageConverter::MapToUNICODE
@DESCRIPTION:	<p>Map the given multibyte chars in the fCodePage codepage into wide UNICODE
	characters. Pass in a buffer 'outChars' of
	size large enough to accomodate those characrters.</p>
		<p>'outCharCnt' is the size of the output buffer coming in, and it contains the number
	of UNICODE chars copied out on return.</p>
*/
void	CodePageConverter::MapToUNICODE (const char* inMBChars, size_t inMBCharCnt, wchar_t* outChars, size_t* outCharCnt) const
{
	Require (inMBCharCnt == 0 or inMBChars != NULL);
	RequireNotNil (outCharCnt);
	Require (*outCharCnt == 0 or outChars != NULL);

	if (GetHandleBOM ()) {
		size_t			bytesToStrip	=	0;
		if (CodePagesGuesser ().Guess (inMBChars, inMBCharCnt, NULL, &bytesToStrip) == fCodePage) {
			Assert (inMBCharCnt >= bytesToStrip);
			inMBChars += bytesToStrip;
			inMBCharCnt -= bytesToStrip;
		}
	}
	switch (fCodePage) {
		case	kCodePage_ANSI:		TableDrivenCodePageConverter<kCodePage_ANSI>::MapToUNICODE (inMBChars, inMBCharCnt, outChars, outCharCnt); break;
		case	kCodePage_MAC:		TableDrivenCodePageConverter<kCodePage_MAC>::MapToUNICODE (inMBChars, inMBCharCnt, outChars, outCharCnt); break;
		case	kCodePage_PC:		TableDrivenCodePageConverter<kCodePage_PC>::MapToUNICODE (inMBChars, inMBCharCnt, outChars, outCharCnt); break;
		case	kCodePage_PCA:		TableDrivenCodePageConverter<kCodePage_PCA>::MapToUNICODE (inMBChars, inMBCharCnt, outChars, outCharCnt); break;
		case	kCodePage_GREEK:	TableDrivenCodePageConverter<kCodePage_GREEK>::MapToUNICODE (inMBChars, inMBCharCnt, outChars, outCharCnt); break;
		case	kCodePage_Turkish:	TableDrivenCodePageConverter<kCodePage_Turkish>::MapToUNICODE (inMBChars, inMBCharCnt, outChars, outCharCnt); break;
		case	kCodePage_HEBREW:	TableDrivenCodePageConverter<kCodePage_HEBREW>::MapToUNICODE (inMBChars, inMBCharCnt, outChars, outCharCnt); break;
		case	kCodePage_ARABIC:	TableDrivenCodePageConverter<kCodePage_ARABIC>::MapToUNICODE (inMBChars, inMBCharCnt, outChars, outCharCnt); break;
		case	kCodePage_UNICODE_WIDE: {
			const wchar_t*	inWChars	=	reinterpret_cast<const wchar_t*> (inMBChars);
			size_t			inWCharCnt	=	(inMBCharCnt / sizeof (wchar_t));
			*outCharCnt = inWCharCnt;
			(void)::memcpy (outChars, inWChars, inWCharCnt * sizeof (wchar_t));
		}
		break;
		case	kCodePage_UNICODE_WIDE_BIGENDIAN: {
			const wchar_t*	inWChars	=	reinterpret_cast<const wchar_t*> (inMBChars);
			size_t			inWCharCnt	=	(inMBCharCnt / sizeof (wchar_t));
			*outCharCnt = inWCharCnt;
			for (size_t i = 0; i < inWCharCnt; ++i) {
				wchar_t	c	=	inWChars[i];
				// byteswap
				c = ((c&0xff) << 8) + (c>>8);
				outChars[i] = c;
			}
		}
		break;
		case	kCodePage_UTF8:		{
			UTF8Converter ().MapToUNICODE (inMBChars, inMBCharCnt, outChars, outCharCnt);
		}
		break;
		default: {
			Win32_CodePageConverter (fCodePage).MapToUNICODE (inMBChars, inMBCharCnt, outChars, outCharCnt);
		}
		break;
	}

#if		defined(_DEBUG)
	// Assure my baked tables (and UTF8 converters) perform the same as the builtin Win32 API
	if (fCodePage == kCodePage_ANSI or
		fCodePage == kCodePage_MAC or
		fCodePage == kCodePage_PC or
		fCodePage == kCodePage_PCA or
		fCodePage == kCodePage_GREEK or
		fCodePage == kCodePage_Turkish or
		fCodePage == kCodePage_HEBREW or
		fCodePage == kCodePage_ARABIC or
		fCodePage == kCodePage_UTF8
	) {
		size_t	tstCharCnt	=	*outCharCnt;
		SmallStackBuffer<wchar_t>	tstBuf (*outCharCnt);

		Win32_CodePageConverter (fCodePage).MapToUNICODE (inMBChars, inMBCharCnt, tstBuf, &tstCharCnt);
		Assert (tstCharCnt == *outCharCnt);
		Assert (memcmp (tstBuf, outChars, sizeof (wchar_t)*tstCharCnt) == 0);
	}
#endif
}

void	CodePageConverter::MapFromUNICODE (const wchar_t* inChars, size_t inCharCnt, char* outChars, size_t* outCharCnt) const
{
	Require (inCharCnt == 0 or inChars != NULL);
	RequireNotNil (outCharCnt);
	Require (*outCharCnt == 0 or outChars != NULL);
	switch (fCodePage) {
		case	kCodePage_ANSI:		TableDrivenCodePageConverter<kCodePage_ANSI>::MapFromUNICODE (inChars, inCharCnt, outChars, outCharCnt); break;
		case	kCodePage_MAC:		TableDrivenCodePageConverter<kCodePage_MAC>::MapFromUNICODE (inChars, inCharCnt, outChars, outCharCnt); break;
		case	kCodePage_PC:		TableDrivenCodePageConverter<kCodePage_PC>::MapFromUNICODE (inChars, inCharCnt, outChars, outCharCnt); break;
		case	kCodePage_PCA:		TableDrivenCodePageConverter<kCodePage_PCA>::MapFromUNICODE (inChars, inCharCnt, outChars, outCharCnt); break;
		case	kCodePage_UNICODE_WIDE: {
			if (*outCharCnt >= 2) {
				wchar_t*	outWBytes		=	reinterpret_cast<wchar_t*> (outChars);
				size_t		outByteCount	=	(inCharCnt * sizeof (wchar_t));
				if (GetHandleBOM ()) {
					outWBytes++;		// skip BOM
					outByteCount -= 2;	// subtract for BOM
				}
				*outCharCnt = outByteCount;
				if (GetHandleBOM ()) {
					outChars[0] = '\xff';
					outChars[1] = '\xfe';
				}
				(void)::memcpy (outWBytes, inChars, inCharCnt * sizeof (wchar_t));
			}
			else {
				*outCharCnt = 0;
			}
		}
		break;
		case	kCodePage_UNICODE_WIDE_BIGENDIAN: {
			if (*outCharCnt >= 2) {
				wchar_t*	outWBytes		=	reinterpret_cast<wchar_t*> (outChars);
				size_t		outByteCount	=	(inCharCnt * sizeof (wchar_t));
				if (GetHandleBOM ()) {
					outWBytes++;		// skip BOM
					outByteCount -= 2;	// subtract for BOM
				}
				*outCharCnt = outByteCount;
				if (GetHandleBOM ()) {
					outChars[0] =  '\xfe';
					outChars[1] =  '\xff';
				}
				for (size_t i = 0; i < inCharCnt; ++i) {
					wchar_t	c	=	inChars[i];
					// byteswap
					c = ((c&0xff) << 8) + (c>>8);
					outWBytes[i] = c;
				}
			}
			else {
				*outCharCnt = 0;
			}
		}
		break;
		case	kCodePage_UTF7: {
			char*	useOutChars		=	outChars;
			size_t	useOutCharCount	=	*outCharCnt;
			if (GetHandleBOM ()) {
				if (*outCharCnt >= 5) {
					useOutChars += 5;	// skip BOM
					useOutCharCount -= 5;
					outChars[0] = 0x2b;
					outChars[1] = 0x2f;
					outChars[2] = 0x76;
					outChars[3] = 0x38;
					outChars[4] = 0x2d;
				}
				else {
					useOutCharCount = 0;
				}
			}
			Win32_CodePageConverter (kCodePage_UTF7).MapFromUNICODE (inChars, inCharCnt, useOutChars, &useOutCharCount);
			if (GetHandleBOM ()) {
				if (*outCharCnt >= 5) {
					useOutCharCount += 5;
				}
			}
			*outCharCnt = useOutCharCount;
		}
		break;
		case	kCodePage_UTF8: {
			char*	useOutChars		=	outChars;
			size_t	useOutCharCount	=	*outCharCnt;
			if (GetHandleBOM ()) {
				if (*outCharCnt >= 3) {
					useOutChars += 3;	// skip BOM
					useOutCharCount -= 3;
					reinterpret_cast<unsigned char*> (outChars)[0] = 0xef;
					reinterpret_cast<unsigned char*> (outChars)[1] = 0xbb;
					reinterpret_cast<unsigned char*> (outChars)[2] = 0xbf;
				}
				else {
					useOutCharCount = 0;
				}
			}
			UTF8Converter ().MapFromUNICODE (inChars, inCharCnt, useOutChars, &useOutCharCount);
			if (GetHandleBOM ()) {
				if (*outCharCnt >= 3) {
					useOutCharCount += 3;
				}
			}
			*outCharCnt = useOutCharCount;
		}
		break;
		default: {
			Win32_CodePageConverter (fCodePage).MapFromUNICODE (inChars, inCharCnt, outChars, outCharCnt);
		}
	}

#if		defined(_DEBUG)
	// Assure my baked tables perform the same as the builtin Win32 API
	if (fCodePage == kCodePage_ANSI or fCodePage == kCodePage_MAC or fCodePage == kCodePage_PC or fCodePage == kCodePage_PCA) {
		size_t						win32TstCharCnt	=	*outCharCnt;
		SmallStackBuffer<char>	win32TstBuf (*outCharCnt);

		Win32_CodePageConverter (fCodePage).MapFromUNICODE (inChars, inCharCnt, win32TstBuf, &win32TstCharCnt);
		// SPR#0813 (and SPR#1277) - assert this produces the right result OR a '?' character -
		// used for bad conversions. Reason is cuz for characters that don't map - our table and
		// the system table can differ in how they map depending on current OS code page.
		Assert (win32TstCharCnt == *outCharCnt or outChars[0] == '?');
		Assert (memcmp (win32TstBuf, outChars, win32TstCharCnt) == 0 or outChars[0] == '?');
	}
#endif
}







/*
 ********************************************************************************
 **************************** Win32_CodePageConverter ***************************
 ********************************************************************************
 */
void	Win32_CodePageConverter::MapToUNICODE (const char* inMBChars, size_t inMBCharCnt, wchar_t* outChars, size_t* outCharCnt) const
{
	Require (inMBCharCnt == 0 or inMBChars != NULL);
	RequireNotNil (outCharCnt);
	Require (*outCharCnt == 0 or outChars != NULL);
//	*outCharCnt	= ::MultiByteToWideChar (fCodePage, MB_ERR_INVALID_CHARS, inMBChars, inMBCharCnt, outChars, *outCharCnt);
	*outCharCnt	= ::MultiByteToWideChar (fCodePage, 0, inMBChars, inMBCharCnt, outChars, *outCharCnt);
#if 0
// enable to debug cases (e.g. caused when you read a CRLF file with fstream
// in text mode, and get - somehow - stuff that triggers this ??? - with convert to
// xml???). Anyhow - get error#102 - BUF_NOT_BIG-ENUF or osmeting like that...
//
// Debug when its happening again -- LGP 2008-09-02
	if (*outCharCnt == 0) {
		DWORD x = GetLastError ();
		int breaker=1;
	}
#endif
}

void	Win32_CodePageConverter::MapFromUNICODE (const wchar_t* inChars, size_t inCharCnt, char* outChars, size_t* outCharCnt) const
{
	Require (inCharCnt == 0 or inChars != NULL);
	RequireNotNil (outCharCnt);
	Require (*outCharCnt == 0 or outChars != NULL);
	*outCharCnt	= ::WideCharToMultiByte (fCodePage, 0, inChars, inCharCnt, outChars, *outCharCnt, NULL, NULL);
}











/*
 ********************************************************************************
 ***************** TableDrivenCodePageConverter<kCodePage_ANSI> *****************
 ********************************************************************************
 */
const	wchar_t		TableDrivenCodePageConverter<kCodePage_ANSI>::kMap[256] = {
		0x0,		0x1,		0x2,		0x3,		0x4,		0x5,		0x6,		0x7,
		0x8,		0x9,		0xa,		0xb,		0xc,		0xd,		0xe,		0xf,
		0x10,		0x11,		0x12,		0x13,		0x14,		0x15,		0x16,		0x17,
		0x18,		0x19,		0x1a,		0x1b,		0x1c,		0x1d,		0x1e,		0x1f,
		0x20,		0x21,		0x22,		0x23,		0x24,		0x25,		0x26,		0x27,
		0x28,		0x29,		0x2a,		0x2b,		0x2c,		0x2d,		0x2e,		0x2f,
		0x30,		0x31,		0x32,		0x33,		0x34,		0x35,		0x36,		0x37,
		0x38,		0x39,		0x3a,		0x3b,		0x3c,		0x3d,		0x3e,		0x3f,
		0x40,		0x41,		0x42,		0x43,		0x44,		0x45,		0x46,		0x47,
		0x48,		0x49,		0x4a,		0x4b,		0x4c,		0x4d,		0x4e,		0x4f,
		0x50,		0x51,		0x52,		0x53,		0x54,		0x55,		0x56,		0x57,
		0x58,		0x59,		0x5a,		0x5b,		0x5c,		0x5d,		0x5e,		0x5f,
		0x60,		0x61,		0x62,		0x63,		0x64,		0x65,		0x66,		0x67,
		0x68,		0x69,		0x6a,		0x6b,		0x6c,		0x6d,		0x6e,		0x6f,
		0x70,		0x71,		0x72,		0x73,		0x74,		0x75,		0x76,		0x77,
		0x78,		0x79,		0x7a,		0x7b,		0x7c,		0x7d,		0x7e,		0x7f,
		0x20ac,		0x81,		0x201a,		0x192,		0x201e,		0x2026,		0x2020,		0x2021,
		0x2c6,		0x2030,		0x160,		0x2039,		0x152,		0x8d,		0x17d,		0x8f,
		0x90,		0x2018,		0x2019,		0x201c,		0x201d,		0x2022,		0x2013,		0x2014,
		0x2dc,		0x2122,		0x161,		0x203a,		0x153,		0x9d,		0x17e,		0x178,
		0xa0,		0xa1,		0xa2,		0xa3,		0xa4,		0xa5,		0xa6,		0xa7,
		0xa8,		0xa9,		0xaa,		0xab,		0xac,		0xad,		0xae,		0xaf,
		0xb0,		0xb1,		0xb2,		0xb3,		0xb4,		0xb5,		0xb6,		0xb7,
		0xb8,		0xb9,		0xba,		0xbb,		0xbc,		0xbd,		0xbe,		0xbf,
		0xc0,		0xc1,		0xc2,		0xc3,		0xc4,		0xc5,		0xc6,		0xc7,
		0xc8,		0xc9,		0xca,		0xcb,		0xcc,		0xcd,		0xce,		0xcf,
		0xd0,		0xd1,		0xd2,		0xd3,		0xd4,		0xd5,		0xd6,		0xd7,
		0xd8,		0xd9,		0xda,		0xdb,		0xdc,		0xdd,		0xde,		0xdf,
		0xe0,		0xe1,		0xe2,		0xe3,		0xe4,		0xe5,		0xe6,		0xe7,
		0xe8,		0xe9,		0xea,		0xeb,		0xec,		0xed,		0xee,		0xef,
		0xf0,		0xf1,		0xf2,		0xf3,		0xf4,		0xf5,		0xf6,		0xf7,
		0xf8,		0xf9,		0xfa,		0xfb,		0xfc,		0xfd,		0xfe,		0xff,
};

void	TableDrivenCodePageConverter<kCodePage_ANSI>::MapToUNICODE (const char* inMBChars, size_t inMBCharCnt, wchar_t* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inMBCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		outChars[i] = kMap[(unsigned char)inMBChars[i]];
	}
	*outCharCnt = nCharsToCopy;
}

void	TableDrivenCodePageConverter<kCodePage_ANSI>::MapFromUNICODE (const wchar_t* inChars, size_t inCharCnt, char* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		size_t j = 0;
		for (; j < 256; ++j) {
			if (kMap[j] == inChars[i]) {
				outChars[i] = j;
				break;
			}
		}
		if (j == 256) {
			/*Perhaps should add extra args to this function - as in Win32 API - for handling this missing-char case*/
			outChars[i] = '?';
		}
	}
	*outCharCnt = nCharsToCopy;
}










/*
 ********************************************************************************
 ********************* TableDrivenCodePageConverter<kCodePage_MAC> **************
 ********************************************************************************
 */
const	wchar_t		TableDrivenCodePageConverter<kCodePage_MAC>::kMap[256] = {
		0x0,		0x1,		0x2,		0x3,		0x4,		0x5,		0x6,		0x7,
		0x8,		0x9,		0xa,		0xb,		0xc,		0xd,		0xe,		0xf,
		0x10,		0x11,		0x12,		0x13,		0x14,		0x15,		0x16,		0x17,
		0x18,		0x19,		0x1a,		0x1b,		0x1c,		0x1d,		0x1e,		0x1f,
		0x20,		0x21,		0x22,		0x23,		0x24,		0x25,		0x26,		0x27,
		0x28,		0x29,		0x2a,		0x2b,		0x2c,		0x2d,		0x2e,		0x2f,
		0x30,		0x31,		0x32,		0x33,		0x34,		0x35,		0x36,		0x37,
		0x38,		0x39,		0x3a,		0x3b,		0x3c,		0x3d,		0x3e,		0x3f,
		0x40,		0x41,		0x42,		0x43,		0x44,		0x45,		0x46,		0x47,
		0x48,		0x49,		0x4a,		0x4b,		0x4c,		0x4d,		0x4e,		0x4f,
		0x50,		0x51,		0x52,		0x53,		0x54,		0x55,		0x56,		0x57,
		0x58,		0x59,		0x5a,		0x5b,		0x5c,		0x5d,		0x5e,		0x5f,
		0x60,		0x61,		0x62,		0x63,		0x64,		0x65,		0x66,		0x67,
		0x68,		0x69,		0x6a,		0x6b,		0x6c,		0x6d,		0x6e,		0x6f,
		0x70,		0x71,		0x72,		0x73,		0x74,		0x75,		0x76,		0x77,
		0x78,		0x79,		0x7a,		0x7b,		0x7c,		0x7d,		0x7e,		0x7f,
		0xc4,		0xc5,		0xc7,		0xc9,		0xd1,		0xd6,		0xdc,		0xe1,
		0xe0,		0xe2,		0xe4,		0xe3,		0xe5,		0xe7,		0xe9,		0xe8,
		0xea,		0xeb,		0xed,		0xec,		0xee,		0xef,		0xf1,		0xf3,
		0xf2,		0xf4,		0xf6,		0xf5,		0xfa,		0xf9,		0xfb,		0xfc,
		0x2020,		0xb0,		0xa2,		0xa3,		0xa7,		0x2022,		0xb6,		0xdf,
		0xae,		0xa9,		0x2122,		0xb4,		0xa8,		0x2260,		0xc6,		0xd8,
		0x221e,		0xb1,		0x2264,		0x2265,		0xa5,		0xb5,		0x2202,		0x2211,
		0x220f,		0x3c0,		0x222b,		0xaa,		0xba,		0x2126,		0xe6,		0xf8,
		0xbf,		0xa1,		0xac,		0x221a,		0x192,		0x2248,		0x2206,		0xab,
		0xbb,		0x2026,		0xa0,		0xc0,		0xc3,		0xd5,		0x152,		0x153,
		0x2013,		0x2014,		0x201c,		0x201d,		0x2018,		0x2019,		0xf7,		0x25ca,
		0xff,		0x178,		0x2044,		0x20ac,		0x2039,		0x203a,		0xfb01,		0xfb02,
		0x2021,		0xb7,		0x201a,		0x201e,		0x2030,		0xc2,		0xca,		0xc1,
		0xcb,		0xc8,		0xcd,		0xce,		0xcf,		0xcc,		0xd3,		0xd4,
		0xf8ff,		0xd2,		0xda,		0xdb,		0xd9,		0x131,		0x2c6,		0x2dc,
		0xaf,		0x2d8,		0x2d9,		0x2da,		0xb8,		0x2dd,		0x2db,		0x2c7,
};

void	TableDrivenCodePageConverter<kCodePage_MAC>::MapToUNICODE (const char* inMBChars, size_t inMBCharCnt, wchar_t* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inMBCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		outChars[i] = kMap[(unsigned char)inMBChars[i]];
	}
	*outCharCnt = nCharsToCopy;
}

void	TableDrivenCodePageConverter<kCodePage_MAC>::MapFromUNICODE (const wchar_t* inChars, size_t inCharCnt, char* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		size_t j = 0;
		for (; j < 256; ++j) {
			if (kMap[j] == inChars[i]) {
				outChars[i] = j;
				break;
			}
		}
		if (j == 256) {
			/*Perhaps should add extra args to this function - as in Win32 API - for handling this missing-char case*/
			outChars[i] = '?';
		}
	}
	*outCharCnt = nCharsToCopy;
}







/*
 ********************************************************************************
 ********************* TableDrivenCodePageConverter<kCodePage_PC> ***************
 ********************************************************************************
 */
const	wchar_t		TableDrivenCodePageConverter<kCodePage_PC>::kMap[256] = {
		0x0,		0x1,		0x2,		0x3,		0x4,		0x5,		0x6,		0x7,
		0x8,		0x9,		0xa,		0xb,		0xc,		0xd,		0xe,		0xf,
		0x10,		0x11,		0x12,		0x13,		0x14,		0x15,		0x16,		0x17,
		0x18,		0x19,		0x1a,		0x1b,		0x1c,		0x1d,		0x1e,		0x1f,
		0x20,		0x21,		0x22,		0x23,		0x24,		0x25,		0x26,		0x27,
		0x28,		0x29,		0x2a,		0x2b,		0x2c,		0x2d,		0x2e,		0x2f,
		0x30,		0x31,		0x32,		0x33,		0x34,		0x35,		0x36,		0x37,
		0x38,		0x39,		0x3a,		0x3b,		0x3c,		0x3d,		0x3e,		0x3f,
		0x40,		0x41,		0x42,		0x43,		0x44,		0x45,		0x46,		0x47,
		0x48,		0x49,		0x4a,		0x4b,		0x4c,		0x4d,		0x4e,		0x4f,
		0x50,		0x51,		0x52,		0x53,		0x54,		0x55,		0x56,		0x57,
		0x58,		0x59,		0x5a,		0x5b,		0x5c,		0x5d,		0x5e,		0x5f,
		0x60,		0x61,		0x62,		0x63,		0x64,		0x65,		0x66,		0x67,
		0x68,		0x69,		0x6a,		0x6b,		0x6c,		0x6d,		0x6e,		0x6f,
		0x70,		0x71,		0x72,		0x73,		0x74,		0x75,		0x76,		0x77,
		0x78,		0x79,		0x7a,		0x7b,		0x7c,		0x7d,		0x7e,		0x7f,
		0xc7,		0xfc,		0xe9,		0xe2,		0xe4,		0xe0,		0xe5,		0xe7,
		0xea,		0xeb,		0xe8,		0xef,		0xee,		0xec,		0xc4,		0xc5,
		0xc9,		0xe6,		0xc6,		0xf4,		0xf6,		0xf2,		0xfb,		0xf9,
		0xff,		0xd6,		0xdc,		0xa2,		0xa3,		0xa5,		0x20a7,		0x192,
		0xe1,		0xed,		0xf3,		0xfa,		0xf1,		0xd1,		0xaa,		0xba,
		0xbf,		0x2310,		0xac,		0xbd,		0xbc,		0xa1,		0xab,		0xbb,
		0x2591,		0x2592,		0x2593,		0x2502,		0x2524,		0x2561,		0x2562,		0x2556,
		0x2555,		0x2563,		0x2551,		0x2557,		0x255d,		0x255c,		0x255b,		0x2510,
		0x2514,		0x2534,		0x252c,		0x251c,		0x2500,		0x253c,		0x255e,		0x255f,
		0x255a,		0x2554,		0x2569,		0x2566,		0x2560,		0x2550,		0x256c,		0x2567,
		0x2568,		0x2564,		0x2565,		0x2559,		0x2558,		0x2552,		0x2553,		0x256b,
		0x256a,		0x2518,		0x250c,		0x2588,		0x2584,		0x258c,		0x2590,		0x2580,
		0x3b1,		0xdf,		0x393,		0x3c0,		0x3a3,		0x3c3,		0xb5,		0x3c4,
		0x3a6,		0x398,		0x3a9,		0x3b4,		0x221e,		0x3c6,		0x3b5,		0x2229,
		0x2261,		0xb1,		0x2265,		0x2264,		0x2320,		0x2321,		0xf7,		0x2248,
		0xb0,		0x2219,		0xb7,		0x221a,		0x207f,		0xb2,		0x25a0,		0xa0,
};

void	TableDrivenCodePageConverter<kCodePage_PC>::MapToUNICODE (const char* inMBChars, size_t inMBCharCnt, wchar_t* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inMBCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		outChars[i] = kMap[(unsigned char)inMBChars[i]];
	}
	*outCharCnt = nCharsToCopy;
}

void	TableDrivenCodePageConverter<kCodePage_PC>::MapFromUNICODE (const wchar_t* inChars, size_t inCharCnt, char* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		size_t j = 0;
		for (; j < 256; ++j) {
			if (kMap[j] == inChars[i]) {
				outChars[i] = j;
				break;
			}
		}
		if (j == 256) {
			/*Perhaps should add extra args to this function - as in Win32 API - for handling this missing-char case*/
			outChars[i] = '?';
		}
	}
	*outCharCnt = nCharsToCopy;
}









/*
 ********************************************************************************
 ********************* TableDrivenCodePageConverter<kCodePage_PCA> **************
 ********************************************************************************
 */
const	wchar_t		TableDrivenCodePageConverter<kCodePage_PCA>::kMap[256] = {
		0x0,		0x1,		0x2,		0x3,		0x4,		0x5,		0x6,		0x7,
		0x8,		0x9,		0xa,		0xb,		0xc,		0xd,		0xe,		0xf,
		0x10,		0x11,		0x12,		0x13,		0x14,		0x15,		0x16,		0x17,
		0x18,		0x19,		0x1a,		0x1b,		0x1c,		0x1d,		0x1e,		0x1f,
		0x20,		0x21,		0x22,		0x23,		0x24,		0x25,		0x26,		0x27,
		0x28,		0x29,		0x2a,		0x2b,		0x2c,		0x2d,		0x2e,		0x2f,
		0x30,		0x31,		0x32,		0x33,		0x34,		0x35,		0x36,		0x37,
		0x38,		0x39,		0x3a,		0x3b,		0x3c,		0x3d,		0x3e,		0x3f,
		0x40,		0x41,		0x42,		0x43,		0x44,		0x45,		0x46,		0x47,
		0x48,		0x49,		0x4a,		0x4b,		0x4c,		0x4d,		0x4e,		0x4f,
		0x50,		0x51,		0x52,		0x53,		0x54,		0x55,		0x56,		0x57,
		0x58,		0x59,		0x5a,		0x5b,		0x5c,		0x5d,		0x5e,		0x5f,
		0x60,		0x61,		0x62,		0x63,		0x64,		0x65,		0x66,		0x67,
		0x68,		0x69,		0x6a,		0x6b,		0x6c,		0x6d,		0x6e,		0x6f,
		0x70,		0x71,		0x72,		0x73,		0x74,		0x75,		0x76,		0x77,
		0x78,		0x79,		0x7a,		0x7b,		0x7c,		0x7d,		0x7e,		0x7f,
		0xc7,		0xfc,		0xe9,		0xe2,		0xe4,		0xe0,		0xe5,		0xe7,
		0xea,		0xeb,		0xe8,		0xef,		0xee,		0xec,		0xc4,		0xc5,
		0xc9,		0xe6,		0xc6,		0xf4,		0xf6,		0xf2,		0xfb,		0xf9,
		0xff,		0xd6,		0xdc,		0xf8,		0xa3,		0xd8,		0xd7,		0x192,
		0xe1,		0xed,		0xf3,		0xfa,		0xf1,		0xd1,		0xaa,		0xba,
		0xbf,		0xae,		0xac,		0xbd,		0xbc,		0xa1,		0xab,		0xbb,
		0x2591,		0x2592,		0x2593,		0x2502,		0x2524,		0xc1,		0xc2,		0xc0,
		0xa9,		0x2563,		0x2551,		0x2557,		0x255d,		0xa2,		0xa5,		0x2510,
		0x2514,		0x2534,		0x252c,		0x251c,		0x2500,		0x253c,		0xe3,		0xc3,
		0x255a,		0x2554,		0x2569,		0x2566,		0x2560,		0x2550,		0x256c,		0xa4,
		0xf0,		0xd0,		0xca,		0xcb,		0xc8,		0x131,		0xcd,		0xce,
		0xcf,		0x2518,		0x250c,		0x2588,		0x2584,		0xa6,		0xcc,		0x2580,
		0xd3,		0xdf,		0xd4,		0xd2,		0xf5,		0xd5,		0xb5,		0xfe,
		0xde,		0xda,		0xdb,		0xd9,		0xfd,		0xdd,		0xaf,		0xb4,
		0xad,		0xb1,		0x2017,		0xbe,		0xb6,		0xa7,		0xf7,		0xb8,
		0xb0,		0xa8,		0xb7,		0xb9,		0xb3,		0xb2,		0x25a0,		0xa0,
};

void	TableDrivenCodePageConverter<kCodePage_PCA>::MapToUNICODE (const char* inMBChars, size_t inMBCharCnt, wchar_t* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inMBCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		outChars[i] = kMap[(unsigned char)inMBChars[i]];
	}
	*outCharCnt = nCharsToCopy;
}

void	TableDrivenCodePageConverter<kCodePage_PCA>::MapFromUNICODE (const wchar_t* inChars, size_t inCharCnt, char* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		size_t j = 0;
		for (; j < 256; ++j) {
			if (kMap[j] == inChars[i]) {
				outChars[i] = j;
				break;
			}
		}
		if (j == 256) {
			/*Perhaps should add extra args to this function - as in Win32 API - for handling this missing-char case*/
			outChars[i] = '?';
		}
	}
	*outCharCnt = nCharsToCopy;
}








/*
 ********************************************************************************
 ******************** TableDrivenCodePageConverter<kCodePage_GREEK> *************
 ********************************************************************************
 */
const	wchar_t		TableDrivenCodePageConverter<kCodePage_GREEK>::kMap[256] = {
		0x0,		0x1,		0x2,		0x3,		0x4,		0x5,		0x6,		0x7,
		0x8,		0x9,		0xa,		0xb,		0xc,		0xd,		0xe,		0xf,
		0x10,		0x11,		0x12,		0x13,		0x14,		0x15,		0x16,		0x17,
		0x18,		0x19,		0x1a,		0x1b,		0x1c,		0x1d,		0x1e,		0x1f,
		0x20,		0x21,		0x22,		0x23,		0x24,		0x25,		0x26,		0x27,
		0x28,		0x29,		0x2a,		0x2b,		0x2c,		0x2d,		0x2e,		0x2f,
		0x30,		0x31,		0x32,		0x33,		0x34,		0x35,		0x36,		0x37,
		0x38,		0x39,		0x3a,		0x3b,		0x3c,		0x3d,		0x3e,		0x3f,
		0x40,		0x41,		0x42,		0x43,		0x44,		0x45,		0x46,		0x47,
		0x48,		0x49,		0x4a,		0x4b,		0x4c,		0x4d,		0x4e,		0x4f,
		0x50,		0x51,		0x52,		0x53,		0x54,		0x55,		0x56,		0x57,
		0x58,		0x59,		0x5a,		0x5b,		0x5c,		0x5d,		0x5e,		0x5f,
		0x60,		0x61,		0x62,		0x63,		0x64,		0x65,		0x66,		0x67,
		0x68,		0x69,		0x6a,		0x6b,		0x6c,		0x6d,		0x6e,		0x6f,
		0x70,		0x71,		0x72,		0x73,		0x74,		0x75,		0x76,		0x77,
		0x78,		0x79,		0x7a,		0x7b,		0x7c,		0x7d,		0x7e,		0x7f,
		0x20ac,		0x81,		0x201a,		0x192,		0x201e,		0x2026,		0x2020,		0x2021,
		0x88,		0x2030,		0x8a,		0x2039,		0x8c,		0x8d,		0x8e,		0x8f,
		0x90,		0x2018,		0x2019,		0x201c,		0x201d,		0x2022,		0x2013,		0x2014,
		0x98,		0x2122,		0x9a,		0x203a,		0x9c,		0x9d,		0x9e,		0x9f,
		0xa0,		0x385,		0x386,		0xa3,		0xa4,		0xa5,		0xa6,		0xa7,
		0xa8,		0xa9,		0xf8f9,		0xab,		0xac,		0xad,		0xae,		0x2015,
		0xb0,		0xb1,		0xb2,		0xb3,		0x384,		0xb5,		0xb6,		0xb7,
		0x388,		0x389,		0x38a,		0xbb,		0x38c,		0xbd,		0x38e,		0x38f,
		0x390,		0x391,		0x392,		0x393,		0x394,		0x395,		0x396,		0x397,
		0x398,		0x399,		0x39a,		0x39b,		0x39c,		0x39d,		0x39e,		0x39f,
		0x3a0,		0x3a1,		0xf8fa,		0x3a3,		0x3a4,		0x3a5,		0x3a6,		0x3a7,
		0x3a8,		0x3a9,		0x3aa,		0x3ab,		0x3ac,		0x3ad,		0x3ae,		0x3af,
		0x3b0,		0x3b1,		0x3b2,		0x3b3,		0x3b4,		0x3b5,		0x3b6,		0x3b7,
		0x3b8,		0x3b9,		0x3ba,		0x3bb,		0x3bc,		0x3bd,		0x3be,		0x3bf,
		0x3c0,		0x3c1,		0x3c2,		0x3c3,		0x3c4,		0x3c5,		0x3c6,		0x3c7,
		0x3c8,		0x3c9,		0x3ca,		0x3cb,		0x3cc,		0x3cd,		0x3ce,		0xf8fb,
};

void	TableDrivenCodePageConverter<kCodePage_GREEK>::MapToUNICODE (const char* inMBChars, size_t inMBCharCnt, wchar_t* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inMBCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		outChars[i] = kMap[(unsigned char)inMBChars[i]];
	}
	*outCharCnt = nCharsToCopy;
}

void	TableDrivenCodePageConverter<kCodePage_GREEK>::MapFromUNICODE (const wchar_t* inChars, size_t inCharCnt, char* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		size_t j = 0;
		for (; j < 256; ++j) {
			if (kMap[j] == inChars[i]) {
				outChars[i] = j;
				break;
			}
		}
		if (j == 256) {
			/*Perhaps should add extra args to this function - as in Win32 API - for handling this missing-char case*/
			outChars[i] = '?';
		}
	}
	*outCharCnt = nCharsToCopy;
}








/*
 ********************************************************************************
 **************** TableDrivenCodePageConverter<kCodePage_Turkish> ***************
 ********************************************************************************
 */
const	wchar_t		TableDrivenCodePageConverter<kCodePage_Turkish>::kMap[256] = {
		0x0,		0x1,		0x2,		0x3,		0x4,		0x5,		0x6,		0x7,
		0x8,		0x9,		0xa,		0xb,		0xc,		0xd,		0xe,		0xf,
		0x10,		0x11,		0x12,		0x13,		0x14,		0x15,		0x16,		0x17,
		0x18,		0x19,		0x1a,		0x1b,		0x1c,		0x1d,		0x1e,		0x1f,
		0x20,		0x21,		0x22,		0x23,		0x24,		0x25,		0x26,		0x27,
		0x28,		0x29,		0x2a,		0x2b,		0x2c,		0x2d,		0x2e,		0x2f,
		0x30,		0x31,		0x32,		0x33,		0x34,		0x35,		0x36,		0x37,
		0x38,		0x39,		0x3a,		0x3b,		0x3c,		0x3d,		0x3e,		0x3f,
		0x40,		0x41,		0x42,		0x43,		0x44,		0x45,		0x46,		0x47,
		0x48,		0x49,		0x4a,		0x4b,		0x4c,		0x4d,		0x4e,		0x4f,
		0x50,		0x51,		0x52,		0x53,		0x54,		0x55,		0x56,		0x57,
		0x58,		0x59,		0x5a,		0x5b,		0x5c,		0x5d,		0x5e,		0x5f,
		0x60,		0x61,		0x62,		0x63,		0x64,		0x65,		0x66,		0x67,
		0x68,		0x69,		0x6a,		0x6b,		0x6c,		0x6d,		0x6e,		0x6f,
		0x70,		0x71,		0x72,		0x73,		0x74,		0x75,		0x76,		0x77,
		0x78,		0x79,		0x7a,		0x7b,		0x7c,		0x7d,		0x7e,		0x7f,
		0x20ac,		0x81,		0x201a,		0x192,		0x201e,		0x2026,		0x2020,		0x2021,
		0x2c6,		0x2030,		0x160,		0x2039,		0x152,		0x8d,		0x8e,		0x8f,
		0x90,		0x2018,		0x2019,		0x201c,		0x201d,		0x2022,		0x2013,		0x2014,
		0x2dc,		0x2122,		0x161,		0x203a,		0x153,		0x9d,		0x9e,		0x178,
		0xa0,		0xa1,		0xa2,		0xa3,		0xa4,		0xa5,		0xa6,		0xa7,
		0xa8,		0xa9,		0xaa,		0xab,		0xac,		0xad,		0xae,		0xaf,
		0xb0,		0xb1,		0xb2,		0xb3,		0xb4,		0xb5,		0xb6,		0xb7,
		0xb8,		0xb9,		0xba,		0xbb,		0xbc,		0xbd,		0xbe,		0xbf,
		0xc0,		0xc1,		0xc2,		0xc3,		0xc4,		0xc5,		0xc6,		0xc7,
		0xc8,		0xc9,		0xca,		0xcb,		0xcc,		0xcd,		0xce,		0xcf,
		0x11e,		0xd1,		0xd2,		0xd3,		0xd4,		0xd5,		0xd6,		0xd7,
		0xd8,		0xd9,		0xda,		0xdb,		0xdc,		0x130,		0x15e,		0xdf,
		0xe0,		0xe1,		0xe2,		0xe3,		0xe4,		0xe5,		0xe6,		0xe7,
		0xe8,		0xe9,		0xea,		0xeb,		0xec,		0xed,		0xee,		0xef,
		0x11f,		0xf1,		0xf2,		0xf3,		0xf4,		0xf5,		0xf6,		0xf7,
		0xf8,		0xf9,		0xfa,		0xfb,		0xfc,		0x131,		0x15f,		0xff,
};

void	TableDrivenCodePageConverter<kCodePage_Turkish>::MapToUNICODE (const char* inMBChars, size_t inMBCharCnt, wchar_t* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inMBCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		outChars[i] = kMap[(unsigned char)inMBChars[i]];
	}
	*outCharCnt = nCharsToCopy;
}

void	TableDrivenCodePageConverter<kCodePage_Turkish>::MapFromUNICODE (const wchar_t* inChars, size_t inCharCnt, char* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		size_t j = 0;
		for (; j < 256; ++j) {
			if (kMap[j] == inChars[i]) {
				outChars[i] = j;
				break;
			}
		}
		if (j == 256) {
			/*Perhaps should add extra args to this function - as in Win32 API - for handling this missing-char case*/
			outChars[i] = '?';
		}
	}
	*outCharCnt = nCharsToCopy;
}









/*
 ********************************************************************************
 ***************** TableDrivenCodePageConverter<kCodePage_HEBREW> ***************
 ********************************************************************************
 */
const	wchar_t		TableDrivenCodePageConverter<kCodePage_HEBREW>::kMap[256] = {
		0x0,		0x1,		0x2,		0x3,		0x4,		0x5,		0x6,		0x7,
		0x8,		0x9,		0xa,		0xb,		0xc,		0xd,		0xe,		0xf,
		0x10,		0x11,		0x12,		0x13,		0x14,		0x15,		0x16,		0x17,
		0x18,		0x19,		0x1a,		0x1b,		0x1c,		0x1d,		0x1e,		0x1f,
		0x20,		0x21,		0x22,		0x23,		0x24,		0x25,		0x26,		0x27,
		0x28,		0x29,		0x2a,		0x2b,		0x2c,		0x2d,		0x2e,		0x2f,
		0x30,		0x31,		0x32,		0x33,		0x34,		0x35,		0x36,		0x37,
		0x38,		0x39,		0x3a,		0x3b,		0x3c,		0x3d,		0x3e,		0x3f,
		0x40,		0x41,		0x42,		0x43,		0x44,		0x45,		0x46,		0x47,
		0x48,		0x49,		0x4a,		0x4b,		0x4c,		0x4d,		0x4e,		0x4f,
		0x50,		0x51,		0x52,		0x53,		0x54,		0x55,		0x56,		0x57,
		0x58,		0x59,		0x5a,		0x5b,		0x5c,		0x5d,		0x5e,		0x5f,
		0x60,		0x61,		0x62,		0x63,		0x64,		0x65,		0x66,		0x67,
		0x68,		0x69,		0x6a,		0x6b,		0x6c,		0x6d,		0x6e,		0x6f,
		0x70,		0x71,		0x72,		0x73,		0x74,		0x75,		0x76,		0x77,
		0x78,		0x79,		0x7a,		0x7b,		0x7c,		0x7d,		0x7e,		0x7f,
		0x20ac,		0x81,		0x201a,		0x192,		0x201e,		0x2026,		0x2020,		0x2021,
		0x2c6,		0x2030,		0x8a,		0x2039,		0x8c,		0x8d,		0x8e,		0x8f,
		0x90,		0x2018,		0x2019,		0x201c,		0x201d,		0x2022,		0x2013,		0x2014,
		0x2dc,		0x2122,		0x9a,		0x203a,		0x9c,		0x9d,		0x9e,		0x9f,
		0xa0,		0xa1,		0xa2,		0xa3,		0x20aa,		0xa5,		0xa6,		0xa7,
		0xa8,		0xa9,		0xd7,		0xab,		0xac,		0xad,		0xae,		0xaf,
		0xb0,		0xb1,		0xb2,		0xb3,		0xb4,		0xb5,		0xb6,		0xb7,
		0xb8,		0xb9,		0xf7,		0xbb,		0xbc,		0xbd,		0xbe,		0xbf,
		0x5b0,		0x5b1,		0x5b2,		0x5b3,		0x5b4,		0x5b5,		0x5b6,		0x5b7,
		0x5b8,		0x5b9,		0x5ba,		0x5bb,		0x5bc,		0x5bd,		0x5be,		0x5bf,
		0x5c0,		0x5c1,		0x5c2,		0x5c3,		0x5f0,		0x5f1,		0x5f2,		0x5f3,
		0x5f4,		0xf88d,		0xf88e,		0xf88f,		0xf890,		0xf891,		0xf892,		0xf893,
		0x5d0,		0x5d1,		0x5d2,		0x5d3,		0x5d4,		0x5d5,		0x5d6,		0x5d7,
		0x5d8,		0x5d9,		0x5da,		0x5db,		0x5dc,		0x5dd,		0x5de,		0x5df,
		0x5e0,		0x5e1,		0x5e2,		0x5e3,		0x5e4,		0x5e5,		0x5e6,		0x5e7,
		0x5e8,		0x5e9,		0x5ea,		0xf894,		0xf895,		0x200e,		0x200f,		0xf896,
};

void	TableDrivenCodePageConverter<kCodePage_HEBREW>::MapToUNICODE (const char* inMBChars, size_t inMBCharCnt, wchar_t* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inMBCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		outChars[i] = kMap[(unsigned char)inMBChars[i]];
	}
	*outCharCnt = nCharsToCopy;
}

void	TableDrivenCodePageConverter<kCodePage_HEBREW>::MapFromUNICODE (const wchar_t* inChars, size_t inCharCnt, char* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		size_t j = 0;
		for (; j < 256; ++j) {
			if (kMap[j] == inChars[i]) {
				outChars[i] = j;
				break;
			}
		}
		if (j == 256) {
			/*Perhaps should add extra args to this function - as in Win32 API - for handling this missing-char case*/
			outChars[i] = '?';
		}
	}
	*outCharCnt = nCharsToCopy;
}








/*
 ********************************************************************************
 ******************** TableDrivenCodePageConverter<kCodePage_ARABIC> ************
 ********************************************************************************
 */
const	wchar_t		TableDrivenCodePageConverter<kCodePage_ARABIC>::kMap[256] = {
		0x0,		0x1,		0x2,		0x3,		0x4,		0x5,		0x6,		0x7,
		0x8,		0x9,		0xa,		0xb,		0xc,		0xd,		0xe,		0xf,
		0x10,		0x11,		0x12,		0x13,		0x14,		0x15,		0x16,		0x17,
		0x18,		0x19,		0x1a,		0x1b,		0x1c,		0x1d,		0x1e,		0x1f,
		0x20,		0x21,		0x22,		0x23,		0x24,		0x25,		0x26,		0x27,
		0x28,		0x29,		0x2a,		0x2b,		0x2c,		0x2d,		0x2e,		0x2f,
		0x30,		0x31,		0x32,		0x33,		0x34,		0x35,		0x36,		0x37,
		0x38,		0x39,		0x3a,		0x3b,		0x3c,		0x3d,		0x3e,		0x3f,
		0x40,		0x41,		0x42,		0x43,		0x44,		0x45,		0x46,		0x47,
		0x48,		0x49,		0x4a,		0x4b,		0x4c,		0x4d,		0x4e,		0x4f,
		0x50,		0x51,		0x52,		0x53,		0x54,		0x55,		0x56,		0x57,
		0x58,		0x59,		0x5a,		0x5b,		0x5c,		0x5d,		0x5e,		0x5f,
		0x60,		0x61,		0x62,		0x63,		0x64,		0x65,		0x66,		0x67,
		0x68,		0x69,		0x6a,		0x6b,		0x6c,		0x6d,		0x6e,		0x6f,
		0x70,		0x71,		0x72,		0x73,		0x74,		0x75,		0x76,		0x77,
		0x78,		0x79,		0x7a,		0x7b,		0x7c,		0x7d,		0x7e,		0x7f,
		0x20ac,		0x67e,		0x201a,		0x192,		0x201e,		0x2026,		0x2020,		0x2021,
		0x2c6,		0x2030,		0x679,		0x2039,		0x152,		0x686,		0x698,		0x688,
		0x6af,		0x2018,		0x2019,		0x201c,		0x201d,		0x2022,		0x2013,		0x2014,
		0x6a9,		0x2122,		0x691,		0x203a,		0x153,		0x200c,		0x200d,		0x6ba,
		0xa0,		0x60c,		0xa2,		0xa3,		0xa4,		0xa5,		0xa6,		0xa7,
		0xa8,		0xa9,		0x6be,		0xab,		0xac,		0xad,		0xae,		0xaf,
		0xb0,		0xb1,		0xb2,		0xb3,		0xb4,		0xb5,		0xb6,		0xb7,
		0xb8,		0xb9,		0x61b,		0xbb,		0xbc,		0xbd,		0xbe,		0x61f,
		0x6c1,		0x621,		0x622,		0x623,		0x624,		0x625,		0x626,		0x627,
		0x628,		0x629,		0x62a,		0x62b,		0x62c,		0x62d,		0x62e,		0x62f,
		0x630,		0x631,		0x632,		0x633,		0x634,		0x635,		0x636,		0xd7,
		0x637,		0x638,		0x639,		0x63a,		0x640,		0x641,		0x642,		0x643,
		0xe0,		0x644,		0xe2,		0x645,		0x646,		0x647,		0x648,		0xe7,
		0xe8,		0xe9,		0xea,		0xeb,		0x649,		0x64a,		0xee,		0xef,
		0x64b,		0x64c,		0x64d,		0x64e,		0xf4,		0x64f,		0x650,		0xf7,
		0x651,		0xf9,		0x652,		0xfb,		0xfc,		0x200e,		0x200f,		0x6d2,
};

void	TableDrivenCodePageConverter<kCodePage_ARABIC>::MapToUNICODE (const char* inMBChars, size_t inMBCharCnt, wchar_t* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inMBCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		outChars[i] = kMap[(unsigned char)inMBChars[i]];
	}
	*outCharCnt = nCharsToCopy;
}

void	TableDrivenCodePageConverter<kCodePage_ARABIC>::MapFromUNICODE (const wchar_t* inChars, size_t inCharCnt, char* outChars, size_t* outCharCnt)
{
	size_t	nCharsToCopy	=	min (inCharCnt, *outCharCnt);
	for (size_t i = 0; i < nCharsToCopy; ++i) {
		size_t j = 0;
		for (; j < 256; ++j) {
			if (kMap[j] == inChars[i]) {
				outChars[i] = j;
				break;
			}
		}
		if (j == 256) {
			/*Perhaps should add extra args to this function - as in Win32 API - for handling this missing-char case*/
			outChars[i] = '?';
		}
	}
	*outCharCnt = nCharsToCopy;
}









/*
 ********************************************************************************
 ********************************** UTF8Converter *******************************
 ********************************************************************************
 */

void	UTF8Converter::MapToUNICODE (const char* inMBChars, size_t inMBCharCnt, wchar_t* outChars, size_t* outCharCnt) const
{
	Require (inMBCharCnt == 0 or inMBChars != NULL);
	RequireNotNil (outCharCnt);
	Require (*outCharCnt == 0 or outChars != NULL);
	
	/*
	 *	NOTE - based on ConvertUTF8toUTF16 () code from ConvertUTF.C, written by Mark E. Davis (mark_davis@taligent.com),
	 *	 and owned by Taligtent. That code is copyrighted. It says it cannot be reproduced without the consent of Taligent,
	 *	but the Taligent company doesn't seem to exist anymore (at least no web site). Also - technically,
	 *	I'm not sure if this is a reproduction, since I've rewritten it (somewhat).
	 *	I hope inclusion of this notice is sufficient. -- LGP 2001-09-15
	 *
	 *	Original code was found refered to on web page:	http://www.czyborra.com/utf/
	 *	and downloaded from URL:						ftp://ftp.unicode.org/Public/PROGRAMS/CVTUTF/
	 *
	 *	NB: I COULD get portable UTF7 code from the same location, but it didn't seem worth the trouble.
	 */
	{
		enum ConversionResult {
			ok, 				/* conversion successful */
			sourceExhausted,	/* partial character in source, but hit end */
			targetExhausted		/* insuff. room in target for conversion */
		};
		typedef unsigned long	UCS4;
		typedef unsigned short	UTF16;
		typedef unsigned char	UTF8;
		const UCS4 kReplacementCharacter =	0x0000FFFDUL;
		const UCS4 kMaximumUCS2 =			0x0000FFFFUL;
		const UCS4 kMaximumUTF16 =			0x0010FFFFUL;
		const UCS4 kMaximumUCS4 =			0x7FFFFFFFUL;
		static	const	char bytesFromUTF8[256] = {
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5};
		static	const	UCS4 offsetsFromUTF8[6] =	{0x00000000UL, 0x00003080UL, 0x000E2080UL, 
					 	 							 0x03C82080UL, 0xFA082080UL, 0x82082080UL};
		const int halfShift				= 10;
		const UCS4 halfBase				= 0x0010000UL;
		const UCS4 halfMask				= 0x3FFUL;
		const UCS4 kSurrogateHighStart	= 0xD800UL;
		const UCS4 kSurrogateHighEnd	= 0xDBFFUL;
		const UCS4 kSurrogateLowStart	= 0xDC00UL;
		const UCS4 kSurrogateLowEnd		= 0xDFFFUL;
		ConversionResult result = ok;
		const UTF8* source = reinterpret_cast<const UTF8*> (inMBChars);
		const UTF8* sourceEnd = source + inMBCharCnt;
		UTF16* target = reinterpret_cast<UTF16*> (outChars);
		UTF16* targetEnd = target + *outCharCnt;
		while (source < sourceEnd) {
			register UCS4 ch = 0;
			register unsigned short extraBytesToWrite = bytesFromUTF8[*source];
			if (source + extraBytesToWrite > sourceEnd) {
				result = sourceExhausted; break;
			};
			switch(extraBytesToWrite) {	/* note: code falls through cases! */
				case 5:	ch += *source++; ch <<= 6;
				case 4:	ch += *source++; ch <<= 6;
				case 3:	ch += *source++; ch <<= 6;
				case 2:	ch += *source++; ch <<= 6;
				case 1:	ch += *source++; ch <<= 6;
				case 0:	ch += *source++;
			};
			ch -= offsetsFromUTF8[extraBytesToWrite];

			if (target >= targetEnd) {
				result = targetExhausted; break;
			};
			if (ch <= kMaximumUCS2) {
				Assert (target < targetEnd);
				*target++ = static_cast<UTF16> (ch);
			} else if (ch > kMaximumUTF16) {
				Assert (target < targetEnd);
				*target++ = kReplacementCharacter;
			} else {
				if (target + 1 >= targetEnd) {
					result = targetExhausted; break;
				};
				ch -= halfBase;
				Assert (target < targetEnd);
				*target++ = static_cast<UTF16> ((ch >> halfShift) + kSurrogateHighStart);
				Assert (target < targetEnd);
				*target++ = static_cast<UTF16> ((ch & halfMask) + kSurrogateLowStart);
			};
		};

		// For now - we ignore ConversionResult flag - and just say how much output was generated...
		//		*sourceStart = source;
		//		*targetStart = target;
		//		return result;
		*outCharCnt = (reinterpret_cast<wchar_t*> (target) - outChars);
	}
}

void	UTF8Converter::MapFromUNICODE (const wchar_t* inChars, size_t inCharCnt, char* outChars, size_t* outCharCnt) const
{
	/*
	 *	NOTE - based on ConvertUTF16toUTF8 () code from ConvertUTF.C, written by Mark E. Davis (mark_davis@taligent.com),
	 *	 and owned by Taligtent. That code is copyrighted. It says it cannot be reproduced without the consent of Taligent,
	 *	but the Taligent company doesn't seem to exist anymore (at least no web site). Also - technically,
	 *	I'm not sure if this is a reproduction, since I've rewritten it (somewhat).
	 *	I hope inclusion of this notice is sufficient. -- LGP 2001-09-15
	 *
	 *	Original code was found refered to on web page:	http://www.czyborra.com/utf/
	 *	and downloaded from URL:						ftp://ftp.unicode.org/Public/PROGRAMS/CVTUTF/
	 *
	 *	NB: I COULD get portable UTF7 code from the same location, but it didn't seem worth the trouble.
	 */
	{
		enum ConversionResult {
			ok, 				/* conversion successful */
			sourceExhausted,	/* partial character in source, but hit end */
			targetExhausted		/* insuff. room in target for conversion */
		};
		typedef unsigned long	UCS4;
		typedef unsigned short	UTF16;
		typedef unsigned char	UTF8;
		const UCS4 kReplacementCharacter =	0x0000FFFDUL;
		const UCS4 kMaximumUCS2 =			0x0000FFFFUL;
		const UCS4 kMaximumUTF16 =			0x0010FFFFUL;
		const UCS4 kMaximumUCS4 =			0x7FFFFFFFUL;
		static	const	char bytesFromUTF8[256] = {
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
			1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
			2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2, 3,3,3,3,3,3,3,3,4,4,4,4,5,5,5,5};
		static	const	UCS4 offsetsFromUTF8[6] =	{0x00000000UL, 0x00003080UL, 0x000E2080UL, 
					 	 							 0x03C82080UL, 0xFA082080UL, 0x82082080UL};
		static	const	UTF8 firstByteMark[7] = {0x00, 0x00, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC};
		const int halfShift				= 10;
		const UCS4 halfBase				= 0x0010000UL;
		const UCS4 halfMask				= 0x3FFUL;
		const UCS4 kSurrogateHighStart	= 0xD800UL;
		const UCS4 kSurrogateHighEnd	= 0xDBFFUL;
		const UCS4 kSurrogateLowStart	= 0xDC00UL;
		const UCS4 kSurrogateLowEnd		= 0xDFFFUL;
		ConversionResult result = ok;
		const UTF16* source = reinterpret_cast <const UTF16*> (inChars);
		const UTF16* sourceEnd = source + inCharCnt;
		UTF8* target = reinterpret_cast<UTF8*> (outChars);
		const UTF8* targetEnd = target + *outCharCnt;
		while (source < sourceEnd) {
			register UCS4 ch;
			register unsigned short bytesToWrite = 0;
			register const UCS4 byteMask = 0xBF;
			register const UCS4 byteMark = 0x80; 
			ch = *source++;
			if (ch >= kSurrogateHighStart && ch <= kSurrogateHighEnd
					&& source < sourceEnd) {
				register UCS4 ch2 = *source;
				if (ch2 >= kSurrogateLowStart && ch2 <= kSurrogateLowEnd) {
					ch = ((ch - kSurrogateHighStart) << halfShift)
						+ (ch2 - kSurrogateLowStart) + halfBase;
					++source;
				};
			};
			if (ch < 0x80) {				bytesToWrite = 1;
			} else if (ch < 0x800) {		bytesToWrite = 2;
			} else if (ch < 0x10000) {		bytesToWrite = 3;
			} else if (ch < 0x200000) {		bytesToWrite = 4;
			} else if (ch < 0x4000000) {	bytesToWrite = 5;
			} else if (ch <= kMaximumUCS4){	bytesToWrite = 6;
			} else {						bytesToWrite = 2;
											ch = kReplacementCharacter;
			}; /* I wish there were a smart way to avoid this conditional */
			
			target += bytesToWrite;
			if (target > targetEnd) {
				target -= bytesToWrite; result = targetExhausted; break;
			};
			switch (bytesToWrite) {	/* note: code falls through cases! */
				case 6:	*--target = static_cast<UTF8> ((ch | byteMark) & byteMask); ch >>= 6;
				case 5:	*--target = static_cast<UTF8> ((ch | byteMark) & byteMask); ch >>= 6;
				case 4:	*--target = static_cast<UTF8> ((ch | byteMark) & byteMask); ch >>= 6;
				case 3:	*--target = static_cast<UTF8> ((ch | byteMark) & byteMask); ch >>= 6;
				case 2:	*--target = static_cast<UTF8> ((ch | byteMark) & byteMask); ch >>= 6;
				case 1:	*--target = static_cast<UTF8> (ch | firstByteMark[bytesToWrite]);
			};
			target += bytesToWrite;
		};
		// For now - we ignore ConversionResult flag - and just say how much output was generated...
		//		*sourceStart = source;
		//		*targetStart = target;
		//		return result;
		*outCharCnt = (target - reinterpret_cast<UTF8*> (outChars));
	}
	#if		0
		/*
		 *	This code is based on comments in the document:	http://www.czyborra.com/utf/
		 *			-- LGP 2001-09-15
		 */
		char*				outP		=	outChars;
		char*				outEOB		=	outChars + *outCharCnt;
		const	wchar_t*	inCharEnd	=	inChars + inCharCnt;
		for (const wchar_t* i = inChars; i < inCharEnd; ++i) {
			wchar_t	c	=	*i;
			if (c < 0x80) {
				if (outP >= outEOB) {
					return;	// outCharCnt already set. Unclear if/how to signal buffer too small?
				}
				*outP++ = c;
			}
			else if (c < 0x800) {
				if (outP + 1 >= outEOB) {
					return;	// outCharCnt already set. Unclear if/how to signal buffer too small?
				}
				*outP++ = (0xC0 | c>>6);
				*outP++ = (0x80 | c & 0x3F);
			}
			else if (c < 0x10000) {
				if (outP + 2 >= outEOB) {
					return;	// outCharCnt already set. Unclear if/how to signal buffer too small?
				}
				*outP++ = (0xE0 | c>>12);
				*outP++ = (0x80 | c>>6 & 0x3F);
				*outP++ = (0x80 | c & 0x3F);
			}
			else if (c < 0x200000) {
				if (outP + 3 >= outEOB) {
					return;	// outCharCnt already set. Unclear if/how to signal buffer too small?
				}
				*outP++ = (0xF0 | c>>18);
				*outP++ = (0x80 | c>>12 & 0x3F);
				*outP++ = (0x80 | c>>6 & 0x3F);
				*outP++ = (0x80 | c & 0x3F);
			}
			else {
				// NOT SURE WHAT TODO HERE??? IGNORE FOR NOW...
			}
		}
		*outCharCnt = (outP - outChars);
	#endif
}






/*
 ********************************************************************************
 ********************************** CodePagesInstalled **************************
 ********************************************************************************
 */
vector<CodePage>	CodePagesInstalled::sCodePages;

BOOL FAR	PASCAL CodePagesInstalled::EnumCodePagesProc (LPTSTR lpCodePageString)
{
	sCodePages.push_back (_ttoi (lpCodePageString));
	return (1);
}

void	CodePagesInstalled::Init ()
{
	Assert (sCodePages.size () == 0);
	::EnumSystemCodePages (EnumCodePagesProc, CP_INSTALLED);
	// Add these 'fake' code pages - which I believe are always available, but never listed by this procedure
	AddIfNotPresent (kCodePage_UNICODE_WIDE);
	AddIfNotPresent (kCodePage_UNICODE_WIDE_BIGENDIAN);
	AddIfNotPresent (kCodePage_UTF8);			// cuz even if OS (e.g. Win98) doesn't support, we have our own baked in code
	std::sort (sCodePages.begin (), sCodePages.end ());
}

void	CodePagesInstalled::AddIfNotPresent (CodePage cp)
{
	if (std::find (sCodePages.begin (), sCodePages.end (), cp) == sCodePages.end ()) {
		sCodePages.push_back (cp);
	}
}






/*
 ********************************************************************************
 ********************************** CodePagesGuesser ****************************
 ********************************************************************************
 */

/*
@METHOD:		CodePagesGuesser::Guess
@DESCRIPTION:	<p>Guess the code page of the given snippet of text. Return that codepage. Always make some guess,
			and return the level of quality of the guess in the optional parameter 'confidence' - unless its NULL (which it is by default),
			and return the number of bytes of BOM (byte-order-mark) prefix to strip from teh source in 'bytesFromFrontToStrip'
			unless it is NULL (which it is by default).</p>
*/
CodePage	CodePagesGuesser::Guess (const void* input, size_t nBytes, Confidence* confidence, size_t* bytesFromFrontToStrip)
{
	if (confidence != NULL) {
		*confidence = eLow;
	}
	if (bytesFromFrontToStrip != NULL) {
		*bytesFromFrontToStrip = 0;
	}
	if (nBytes >= 2) {
		unsigned char	c0	=	reinterpret_cast<const unsigned char*> (input)[0];
		unsigned char	c1	=	reinterpret_cast<const unsigned char*> (input)[1];
		if (c0 == 0xff and c1 == 0xfe) {
			if (confidence != NULL) {
				*confidence = eHigh;
			}
			if (bytesFromFrontToStrip != NULL) {
				*bytesFromFrontToStrip = 2;
			}
			return kCodePage_UNICODE_WIDE;
		}
		if (c0 == 0xfe and c1 == 0xff) {
			if (confidence != NULL) {
				*confidence = eHigh;
			}
			if (bytesFromFrontToStrip != NULL) {
				*bytesFromFrontToStrip = 2;
			}
			return kCodePage_UNICODE_WIDE_BIGENDIAN;
		}
		if (nBytes >= 3) {
			unsigned char	c2	=	reinterpret_cast<const unsigned char*> (input)[2];
			if (c0 == 0xef and c1 == 0xbb and c2 == 0xbf) {
				if (confidence != NULL) {
					*confidence = eHigh;
				}
				if (bytesFromFrontToStrip != NULL) {
					*bytesFromFrontToStrip = 3;
				}
				return kCodePage_UTF8;
			}
		}
		if (nBytes >= 5) {
			unsigned char	c2	=	reinterpret_cast<const unsigned char*> (input)[2];
			unsigned char	c3	=	reinterpret_cast<const unsigned char*> (input)[3];
			unsigned char	c4	=	reinterpret_cast<const unsigned char*> (input)[4];
			if (c0 == 0x2b and c1 == 0x2f and c2 == 0x76 and c3 == 0x38 and c4 == 0x2d) {
				if (confidence != NULL) {
					*confidence = eHigh;
				}
				if (bytesFromFrontToStrip != NULL) {
					*bytesFromFrontToStrip = 5;
				}
				return kCodePage_UTF7;
			}
		}
	}


	/*
	 * Final ditch efforts if we don't recognize any prefix.
	 */
	if (confidence != NULL) {
		*confidence = eLow;
	}
	return ::GetACP ();
}











// For gnuemacs:
// Local Variables: ***
// mode:c++ ***
// tab-width:4 ***
// End: ***

