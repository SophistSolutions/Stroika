{\rtf1 \ansi {\fonttbl {\f0 \fnil Times New Roman;}{\f1 \fnil Courier New;}}{\colortbl \red255\green0\blue0;\red0\green0\blue0;}
{\*\listtable{\list \listtemplateid16827 {\listlevel \levelnfc23 \leveljc0 \levelfollow0 \levelstartat1 \levelindent0 {\leveltext \levelnfc23 \leveltemplateid9961 \'01\u8226  ?;}\f0 \fi-360 \li720 \jclisttab \tx720 }\listid23281 }}
{\*\listoverridetable{\listoverride \listid23281 \listoverridecount0 \ls1 }}
\deftab720 \pard \qc \tx6048 \plain \f0 \fs48 \b \ul \cf0 NetLedIt!\plain \f0 \fs48 \cf1   3.0 Reference\plain \f1 \fs24 \cf1 \par \pard \plain \f0 \fs24 \cf1 \par \pard \li270 \par \pard \li270 \tab NetLedIt! is controlled via the Java plugin API. Thi
s is callable directly and straight-forwardly from Javascript in the browser.\par \pard \li270 \par \pard \li270 \par \pard \li270 
\plain \f0 \fs28 \b \ul \cf1 NetLedIt! \plain \f0 \fs28 \b \i \ul \cf1 <EMBED>\plain \f0 \fs28 \b \ul \cf1  tag arguments:\plain \f0 \fs24 \cf1 \par \pard \li270 \par \pard \li270 \tab See the web page sample ScriptingSampleNetLed
ItPage.html' for an example of how to use the <EMBED> tags.\par \pard \li270 \par \pard \tx6480 \li270 \plain \f1 \fs24 \b \cf1 src\plain \f1 \fs24 \cf1 \par \pard \li270 \tab \plain \f0 \fs24 \cf1 Specifies the 
URL of a file which can be loaded with the initial value of the plugin. See the 
sample file ScriptingSampleNetLedItPage.html for an example.\par \pard \tx6480 \li270 \par \pard \li270 \par \pard \li270 \plain \f0 \fs28 \b \ul \cf1 NetLedIt! Java In
terface:\plain \f0 \fs24 \cf1 \par \pard \li270 \par \pard \li270 \plain \f0 \fs24 \b \ul \cf1 Properties:\par \pard \li270 \plain \f0 \fs24 \cf1 \tab These can be both retrieved, and set (analogous to get/se
t methods).\par \pard \li270 \plain \f1 \fs20 \cf1 int\tab \tab \plain \f1 \fs20 \b \cf1 GetVersionNumber\plain \f1 \fs20 \cf1  ();\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Returns the NetLedIt! numeric version num
ber. The form of the version number is a 4-byte longword, computed as:\par \pard \li270 \tab \plain \f1 \fs18 \cf1 value=\tab (
static_cast<unsigned long> (majorMinor)<<24) |\par \pard \li270 \tab \tab (static_cast<unsigned long> (ve
rsStage)<<16) |\par \pard \li270 \tab \tab (static_cast<unsigned long> (subStage)<<8) |\par \pard \li270 \tab \tab (static_cast<un
signed long> (nonDemoFlag)<<0);\plain \f0 \fs24 \cf1 \par \pard \li270 \tab \plain \f1 \fs18 \cf1 #define\tab qLed_Version_Stage_Dev\tab \tab \tab 0x1\par \pard \li270 \tab #define\tab q
Led_Version_Stage_Alpha\tab \tab \tab 0x2\par \pard \li270 \tab #define\tab qLed_Version_Stage_Beta\tab \tab \tab 0x3\par \pard \li270 \tab #define\tab qL
ed_Version_Stage_ReleaseCandidate\tab 0x4\par \pard \li270 \tab #define\tab qLed_Version_Stage_Release\tab \tab \tab 0x5\par \pard \li270 
\plain \f0 \fs24 \cf1 \par \pard \li270 \tab So, for example, NetLedIt! 3.0b7 (demo version) should have a hex version# of 
0x30030700. Note - this is the same value as the Win32 FILEVERSION. See also \plain \f1 \fs20 \cf1 Get
ShortVersionString ().\plain \f0 \fs24 \cf1 \par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 int\tab \tab \plain \f1 \fs20 \b \cf1 GetShortVersionString\plain \f1 \fs20 \cf1  ();\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Returns a string repres
entation of the NetLedIt! version. For example, it might return "3.0b8 - Demo Ve
rsion" or "3.0b8".\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 boolean\tab \plain \f1 \fs20 \b \cf1 GetDirty\plain \f1 \fs20 \cf1  ();\par \pard \li270 void\tab \plain \f1 \fs20 \b \cf1 SetDirty\plain \f1 \fs20 \cf1  (boolean dirty);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Docume
nt dirty. Automatically set dirty by editing. But flag only cleared by explicitl
y setting this property.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 final\tab static\tab int\tab \plain \f1 \fs20 \b \cf1 eNoScrollBar\plain \f1 \fs20 \cf1 \tab \tab =\tab 0;\par \pard \li270 final\tab static\tab int\tab 
\plain \f1 \fs20 \b \cf1 eShowScrollBar\plain \f1 \fs20 \cf1 \tab \tab =\tab 1;\par \pard \li270 final\tab static\tab int\tab \plain \f1 \fs20 \b \cf1 eShowScrollbarIfNeeded\plain \f1 \fs20 \cf1 \tab =\tab 2;\par \pard \li270 public native 
int\tab \plain \f1 \fs20 \b \cf1 GetHasVerticalScrollBar\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f1 \fs20 \b \cf1 SetHasVerticalScrollBar\plain \f1 \fs20 \cf1  (int 
scrollBarFlag);\par \pard \li270 public native int\tab \plain \f1 \fs20 \b \cf1 GetHasHorizontalScrollBar\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native vo
id\tab \plain \f1 \fs20 \b \cf1 SetHasHorizontalScrollBar\plain \f1 \fs20 \cf1  (int scrollBarFlag);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab This property defines whether
 or not NetLedIt! displays a scrollbar (vertically or horizontally).  \plain \f0 \fs24 \b \cf1 eShowScrol
lbarIfNeeded\plain \f0 \fs24 \cf1  means that the scrollbar is shown and hidden automatically, dependi
ng on how much text is being displayed.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native int\tab \plain \f1 \fs20 \b \cf1 GetMaxUndoLevel\plain \f1 \fs20 \cf1  ();\par \pard \li270 
public native void\tab \plain \f1 \fs20 \b \cf1 SetMaxUndoLevel\plain \f1 \fs20 \cf1  (int maxUndoLevel);\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 0 implies no undo, and 1
 implies UNDO has same effect as REDO. Values >1 imply Undo/Redo methods do diff
erent things. Check CanUndo/CanRedo for more info.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs18 \cf1 public native boolean\tab \plain \f1 \fs18 \b \cf1 GetCa
nUndo\plain \f1 \fs18 \cf1  ();\plain \f1 \fs24 \cf1 \par \pard \li270 \tab \plain \f0 \fs24 \cf1 OK to call Undo () function - something user has done which can be un
done\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native boolean\tab \plain \f1 \fs20 \b \cf1 GetCanRedo\plain \f1 \fs20 \cf1  ();\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 OK to call Redo () function - somet
hing user has undone which can be redone\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native String\tab \plain \f1 \fs20 \b \cf1 GetText\plain \f1 \fs20 \cf1  ();\par \pard \li270 publ
ic native void\tab \plain \f1 \fs20 \b \cf1 SetText\plain \f1 \fs20 \cf1  (String text);\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 Returns/sets ALL the text. Returns LF cha
racters as line term (but accepts ANY standard line term on input)\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public nati
ve String\tab \plain \f1 \fs20 \b \cf1 GetTextCRLF\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f1 \fs20 \b \cf1 SetTextCRLF\plain \f1 \fs20 \cf1  (String textCRLF);\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 Ret
urns/sets ALL the text. Always returns CR/LF terminated text - even though Led i
nternally uses a single LF for paragraph termination. So length of this string i
sn't same.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f0 \fs20 \cf1 public native String\tab \plain \f0 \fs20 \b \cf1 GetTextRTF\plain \f0 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f0 \fs20 \b \cf1 SetTextRTF\plain \f0 \fs20 \cf1  (
String rtfText);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Returns/sets ALL the text. The format of the property is RTF.\par \pard \li270 
\par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native String\tab \plain \f1 \fs20 \b \cf1 GetTextHTML\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f1 \fs20 \b \cf1 SetTextHTML\plain \f1 \fs20 \cf1  (String \plain \f1 \fs24 \cf1 rt
fText);\par \pard \li270 \tab \plain \f0 \fs24 \cf1 Returns/sets ALL the text. The format of the property is HTML.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public
 native  int\tab \plain \f1 \fs20 \b \cf1 GetLength\plain \f1 \fs20 \cf1  ();\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 Returns the total number of characters in the buffer
. Note this DOESNT correspond to length (Text), cuz that returns CRLF text\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 pub
lic native int\tab \plain \f1 \fs20 \b \cf1 GetMaxLength\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f1 \fs20 \b \cf1 SetMaxLength\plain \f1 \fs20 \cf1  (int maxLength);
\plain \f1 \fs24 \cf1 \par \pard \li270 \tab \plain \f0 \fs24 \cf1 Maximum length (in characters, with CR/LF treated as ONE) of the input buffer.
 -1 => no maximum.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native boolean\tab \plain \f1 \fs20 \b \cf1 GetSupportContextMenu\plain \f1 \fs20 \cf1  ();\par \pard \li270 public nati
ve void\tab \plain \f1 \fs20 \b \cf1 SetSupportContextMenu\plain \f1 \fs20 \cf1  (\par \pard \li270 \tab \tab \tab \tab \tab boolean supportContextMenu\par \pard \li270 \tab \tab \tab \tab );\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 If enabl
ed, right-clicks bring up context menu.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native boolean\tab \plain \f1 \fs20 \b \cf1 GetSmartCutAndPa
ste\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f1 \fs20 \b \cf1 SetSmartCutAndPaste\plain \f1 \fs20 \cf1  (boolean smartCutAndPaste);\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 If e
nabled, try to make good guesses about cutting/pasting extra whitespace (and dra
g and drop).\par \pard \li270 \plain \f1 \fs24 \cf1 \par \pard \li270 \plain \f0 \fs24 \cf1 \par \pard \li270 \plain \f1 \fs20 \cf1 public native boolean\tab \plain \f1 \fs20 \b \cf1 GetWrapToWindow\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f1 \fs20 \b \cf1 SetW
rapToWindow\plain \f1 \fs20 \cf1  (boolean wrapToWindow);\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 If true, then text is wrapped to the window
, and otherwise to the ruler (page). This only affects the rightmost margin.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 p
ublic native boolean\tab \plain \f1 \fs20 \b \cf1 GetShowParagraphGlyphs\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f1 \fs20 \b \cf1 SetShowParagr
aphGlyphs\plain \f1 \fs20 \cf1  (\par \pard \li270 \tab \tab \tab \tab \tab boolean showParagraphGlyphs\par \pard \li270 \tab \tab \tab \tab );\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 If true, end-of-paragraph g
lyphs are displayed.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native boolean\tab \plain \f1 \fs20 \b \cf1 GetShowTabGlyphs\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native 
void\tab \plain \f1 \fs20 \b \cf1 SetShowTabGlyphs\plain \f1 \fs20 \cf1  (boolean showTabGlyphs);\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 If true, tab glyphs are displaye
d (not just empty space - but an icon so you can see them).\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native bool
ean\tab \plain \f1 \fs20 \b \cf1 GetShowSpaceGlyphs\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f1 \fs20 \b \cf1 SetShowSpaceGlyphs\plain \f1 \fs20 \cf1  (boolean showSp
aceGlyphs);\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 If true, space glyphs are displayed (not just empty space - but an 
icon so you can see them\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native boolean\tab \plain \f1 \fs20 \b \cf1 GetShowHidableText\plain \f1 \fs20 \cf1  ();\par \pard \li270 public n
ative void\tab \plain \f1 \fs20 \b \cf1 SetShowHidableText\plain \f1 \fs20 \cf1  (boolean showHidableText);\plain \f1 \fs24 \cf1 \par \pard \li270 \tab \plain \f0 \fs24 \cf1 If true, hidable text 
(RTF \\v) is displayed in the HidableTextColor, and the strike-through style.\par \pard \li270 \tab \tab \tab 
\par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native int\tab \plain \f1 \fs20 \b \cf1 GetHidableTextColor\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f1 \fs20 \b \cf1 SetHidableTextCol
or\plain \f1 \fs20 \cf1  (int hidableTextColor);\plain \f1 \fs24 \cf1 \par \pard \li270 \tab \plain \f0 \fs24 \cf1 See ShowHidableText. This color is used to augment t
he display of hidable text which is currently being displayed if HidableTextColo
red is true.\par \pard \li270 \tab \tab \tab \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native boolean\tab \plain \f1 \fs20 \b \cf1 GetHidableTextColored\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native 
void\tab \plain \f1 \fs20 \b \cf1 SetHidableTextColored\plain \f1 \fs20 \cf1  (\par \pard \li270 \tab \tab \tab \tab \tab boolean hidableTextColored\par \pard \li270 \tab \tab \tab \tab );\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 See ShowHid
ableText. If true, then use 'HidableTextColor' to color hidable text which is sh
own. Otherwise - use (default) light gray underline.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native int\tab \plain \f1 \fs20 \b \cf1 GetSelS
tart\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f1 \fs20 \b \cf1 SetSelStart\plain \f1 \fs20 \cf1  (int selStart);\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 Returns/sets START of t
he selection (nb: offsets assume a paragraph-term single char).\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f0 \fs20 \cf1 public native 
int\tab \plain \f0 \fs20 \b \cf1 GetSelLength\plain \f0 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f0 \fs20 \b \cf1 SetSelLength\plain \f0 \fs20 \cf1  (int selLength);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Returns/s
ets LENGTH of the selection (nb: offsets assume a paragraph-term single char).\par \pard \li270 \par \pard \li270 
\par \pard \li270 \plain \f0 \fs20 \cf1 public native String\tab \plain \f0 \fs20 \b \cf1 GetSelText\plain \f0 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f0 \fs20 \b \cf1 SetSelText\plain \f0 \fs20 \cf1  (String selTe
xt);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Returns/sets the selected text (if any).  (but accepts ANY standard line t
erm on input\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native String\tab \plain \f1 \fs20 \b \cf1 GetSelTextRTF\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f1 \fs20 \b \cf1 SetSelT
extRTF\plain \f1 \fs20 \cf1  (String selTextRTF);\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 Returns/sets the selected text (in RTF format - and
 can be stuff other than text - so long as in RTF format.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f0 \fs20 \cf1 public native String
\tab \plain \f0 \fs20 \b \cf1 GetSelTextHTML\plain \f0 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f0 \fs20 \b \cf1 SetSelTextHTML\plain \f0 \fs20 \cf1  (String selTextHTML);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Ret
urns/sets the selected text (in RTF format - and can be stuff other than text - 
so long as in RTF format).\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f0 \fs20 \cf1 public native int\tab \plain \f0 \fs20 \b \cf1 GetSelColor\plain \f0 \fs20 \cf1  ();\par \pard \li270 public native voi
d\tab \plain \f0 \fs20 \b \cf1 SetSelColor\plain \f0 \fs20 \cf1  (int selColor);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Returns/sets the color of the selected text (or i
nsertion point if selection empty).\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f0 \fs20 \cf1 public native String\tab \plain \f0 \fs20 \b \cf1 GetSelFontFace\plain \f0 \fs20 \cf1  ();\par \pard \li270 pu
blic native void\tab \plain \f0 \fs20 \b \cf1 SetSelFontFace\plain \f0 \fs20 \cf1  (String selFontFace);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Returns/sets the FontFace
 of the selected text (or insertion point if selection empty).\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f0 \fs20 \cf1 public native i
nt\tab \plain \f0 \fs20 \b \cf1 GetSelFontSize\plain \f0 \fs20 \cf1  ();\par \pard \li270  public native void\tab \plain \f0 \fs20 \b \cf1 SetSelFontSize\plain \f0 \fs20 \cf1  (int selFontSize);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Ret
urns/sets the Font Size of the selected text (or insertion point if selection em
pty - in Points).\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 public native int\tab \plain \f1 \fs20 \b \cf1 GetSelBold\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f1 \fs20 \b \cf1 SetSelBo
ld\plain \f1 \fs20 \cf1  (int selBold);\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 Returns/sets the Font Style BOLD of the selected text (or ins
ertion point if selection empty). 0=>false, 1=>true, 2=>no-universal-answer.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f0 \fs20 \cf1 p
ublic native int\tab \plain \f0 \fs20 \b \cf1 GetSelItalic\plain \f0 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f0 \fs20 \b \cf1 SetSelItalic\plain \f0 \fs20 \cf1  (int selItalic
);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Returns/sets the Font Style Italic of the selected text (or insertion point 
if selection empty). 0=>false, 1=>true, 2=>no-universal-answer.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f0 \fs20 \cf1 public native 
int\tab \plain \f0 \fs20 \b \cf1 GetSelUnderline\plain \f0 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f0 \fs20 \b \cf1 SetSelUnderline\plain \f0 \fs20 \cf1  (int selUnderline);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab 
Returns/sets the Font Style Underline of the selected text (or insertion point i
f selection empty). 0=>false, 1=>true, 2=>no-universal-answer.\par \pard \li270 \par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 final\tab static\tab i
nt\tab \plain \f1 \fs20 \b \cf1 eLeftJustification\plain \f1 \fs20 \cf1 \tab \tab =\tab 0;\par \pard \li270 final\tab static\tab int\tab \plain \f1 \fs20 \b \cf1 eRightJustification\plain \f1 \fs20 \cf1 \tab \tab =\tab 1;\par \pard \li270 final\tab sta
tic\tab int\tab \plain \f1 \fs20 \b \cf1 eCenterJustification\plain \f1 \fs20 \cf1 \tab \tab =\tab 2;\par \pard \li270 final\tab static\tab int\tab \plain \f1 \fs20 \b \cf1 eFullJustification\plain \f1 \fs20 \cf1 \tab \tab =\tab 3;\par \pard \li270 fin
al\tab static\tab int\tab \plain \f1 \fs20 \b \cf1 eNoCommonJustification\plain \f1 \fs20 \cf1 \tab \tab =\tab 4;\par \pard \li270 public native int\tab \plain \f1 \fs20 \b \cf1 GetSelJustification
\plain \f1 \fs20 \cf1  ();\par \pard \li270 public native void\tab \plain \f1 \fs20 \b \cf1 SetSelJustification\plain \f1 \fs20 \cf1  (int selJustification);\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 Returns/set
s the Justification of the selected paragraphs. eNoCommonJustification =>no-univ
ersal-answer, can be returned - but not set. FullJustification not fully support
ed (displayed as left-justification).\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f0 \fs20 \cf1 public native int\tab \plain \f0 \fs20 \b \cf1 GetSelHidable\plain \f0 \fs20 \cf1  ();\par \pard \li270 publ
ic native void\tab \plain \f0 \fs20 \b \cf1 SetSelHidable\plain \f0 \fs20 \cf1  (int selHidable);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Returns/sets the Hidable flag of
 the selected text. 0=>false, 1=>true, 2=>no-universal-answer.\par \pard \li270 \par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f0 \fs24 \b \ul \cf1 Methods:\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Thes
e are normal methods (functions) which apply to the given NetLedIt! control (not
 to be confused with properties).\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 void \plain \f1 \fs20 \b \cf1 AboutBox\plain \f1 \fs20 \cf1  ();\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Displays the modal aboutb
ox.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 void \plain \f1 \fs20 \b \cf1 LoadFile\plain \f1 \fs20 \cf1  (String filename);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Loads a file into the control. This rout
ine will guess the file format, based on the file extension, and perhaps its con
tents.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 void \plain \f1 \fs20 \b \cf1 SaveFile\plain \f1 \fs20 \cf1  (String filename);\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 Saves the contents of the control to 
the named file. Guess the file format based on the file name.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 void \plain \f1 \fs20 \b \cf1 SaveFileCRL
F\plain \f1 \fs20 \cf1  (String filename);\tab \par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 Saves the contents of the control to the named file as CR
LF-terminated text.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 void \plain \f1 \fs20 \b \cf1 SaveFileRTF\plain \f1 \fs20 \cf1  (String filename);\par \pard \li270 \plain \f1 \fs24 \cf1 \tab \plain \f0 \fs24 \cf1 Saves the contents of
 the control to the named file as RTF.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 void \plain \f1 \fs20 \b \cf1 SaveFileHTML\plain \f1 \fs20 \cf1  (String filename);\par \pard \li270 \plain \f0 \fs24 \cf1 \tab S
aves the contents of the control to the named file as HTML.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 void \plain \f1 \fs20 \b \cf1 Refresh\plain \f1 \fs20 \cf1  ();\par \pard \li270 \plain \f0 \fs24 \cf1 \tab 
Forces a complete repaint of a control.\tab \par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 void \plain \f1 \fs20 \b \cf1 ScrollToSelection\plain \f1 \fs20 \cf1  ();\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Scroll th
e current window so that the selection is shown.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 void \plain \f1 \fs20 \b \cf1 Undo\plain \f1 \fs20 \cf1  ();\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Undo last user
 action (same as menu command undo). If CanRedo and MaxUndoLevel==1, same as Red
o (). NB: unlike UI undo command - doesn't scrolltoselection afterwards.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 void 
\plain \f1 \fs20 \b \cf1 Redo\plain \f1 \fs20 \cf1  ();\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Redo last undone action (same as menu command redo). NB: unlike UI und
o command - doesn't scrolltoselection afterwards.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 void \plain \f1 \fs20 \b \cf1 CommitUndo\plain \f1 \fs20 \cf1  ();\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Erases 
existing Undo/Redo history. Future user actions can still be undone.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 void \plain \f1 \fs20 \b \cf1 Laun
chFindDialog\plain \f1 \fs20 \cf1  ();\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Bring up the Find Dialog, so the user can type in text and sea
rch. See also the 'Find' method.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 long \plain \f1 \fs20 \b \cf1 Find\plain \f1 \fs20 \cf1  (\par \pard \li270 \tab \tab int searchFrom,\par \pard \li270 \tab \tab String findTe
xt,\par \pard \li270 \tab \tab boolean wrapSearch,\par \pard \li270 \tab \tab boolean wholeWordSearch,\par \pard \li270 \tab \tab boolean caseSensativeSear
ch\par \pard \li270 \tab );\par \pard \li270 \plain \f0 \fs24 \cf1 \tab Search from the given position, using the given parameters. Return offse
t in text where specified string is found, or -1 if none. Doesn't change selecti
on. See also the 'LaunchFindDialog' method.\par \pard \li270 \par \pard \li270 \par \pard \li270 \plain \f1 \fs20 \cf1 int \plain \f1 \fs20 \b \cf1 GetHeight\plain \f1 \fs20 \cf1  (int from, int to);\par \pard \li270 
\plain \f0 \fs24 \cf1 \tab Compute the height of the given document range (from to to) in pixels. 'from' a
nd 'to' default to the start and end of the document\par \pard \li270 \tab  Note this function can be
 slow to compute for large documents - as it may cause word-wrap computations fo
r the entire range requested.\par \pard \li270 \tab Note also that this does \plain \f0 \fs24 \i \cf1 not\plain \f0 \fs24 \cf1  exactly compute the 
number of pages you would expect when printing - because printing often inserts 
extra spaces at the end of pages so we don't display partial rows.\par \pard \li270 \tab This functio
n includes the last row referenced in its heihgt computation. So - for example -
 if you ask for the height from X,X - you WONT get back zero - but the height of
 the row containing position X.\par \pard \li270 \par \pard \li270 \par \pard }